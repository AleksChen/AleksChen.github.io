const _astro_dataLayerContent = [["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.16.5","content-config-digest","97fa3ad022746000","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://blog.002085.xyz\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"never\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":true,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false,\"svgo\":false},\"legacy\":{\"collections\":false}}","posts",["Map",11,12,25,26,37,38,48,49,61,62,74,75,86,87],"1708-implement-instanceof",{id:11,data:13,body:20,filePath:21,digest:22,legacyId:23,deferredRender:24},{title:14,date:15,updatedAt:16,tags:17,draft:19},"手写 instanceof",["Date","2017-08-23T03:32:22.000Z"],["Date","2024-12-02T09:46:21.280Z"],[18],"JavaScript",false,"在前端面试中，`instanceof` 是一个常见的问题。面试官通常会要求面试者手写 `instanceof` 的实现，以测试他们对 JavaScript 类型系统和原型链的理解。\n\n## 类型判断\n\n在 JavaScript 中数据分为基本类型和引用类型。\n\n基本类型\n\n- `Number`\n- `String`\n- `Boolean`\n- `undefined`\n- `null`\n- `Symbol`\n- `BigInt`\n\n引用类型\n\n- `Object`\n- `Array`\n- `Function`\n- `Date`\n- `RegExp`\n- `Map`\n- `Set`\n- `Promise`\n- ...\n\n在实际工作中，我们常常需要判断一个变量的类型。对于基本类型(`null` 除外) 和 `Function` 我们可以使用 `typeof` 进行判断。对于引用类型我们则需要使用 `instanceof` 进行判断。\n\n```javascript\n// 基本数据类型\nlet numberExample = 123;\nlet stringExample = \"hello\";\nlet booleanExample = true;\nlet nullExample = null;\nlet undefinedExample = undefined;\nlet symbolExample = Symbol(\"example\");\nlet bigIntExample = BigInt(10);\n\n// 引用类型\nlet objectExample = {};\nlet arrayExample = [];\nlet functionExample = function () {};\nlet dateExample = new Date();\nlet regExpExample = /abc/;\nlet mapExample = new Map();\nlet setExample = new Set();\nlet promiseExample = new Promise(() => {});\n\n// typeof 适用范围\nconsole.log(typeof numberExample); // number\nconsole.log(typeof stringExample); // string\nconsole.log(typeof booleanExample); // boolean\nconsole.log(typeof undefinedExample); // undefined\nconsole.log(typeof symbolExample); // symbol\nconsole.log(typeof bigIntExample); // bigint\nconsole.log(typeof functionExample); // function\n\n// typeof 对 null 和于其他引用类型无法判断\nconsole.log(typeof nullExample); // object。这是一个历史遗留问题，实际上 null 是基本数据类型\nconsole.log(typeof objectExample); // object\nconsole.log(typeof arrayExample); // object\nconsole.log(typeof dateExample); // object\nconsole.log(typeof regExpExample); // object\nconsole.log(typeof mapExample); // object\nconsole.log(typeof setExample); // object\nconsole.log(typeof promiseExample); // object\n\n// instanceof 判断对象具体是哪种类型的对象\nconsole.log(objectExample instanceof Object); // true\nconsole.log(arrayExample instanceof Array); // true\nconsole.log(functionExample instanceof Function); // true\nconsole.log(dateExample instanceof Date); // true\nconsole.log(regExpExample instanceof RegExp); // true\nconsole.log(mapExample instanceof Map); // true\nconsole.log(setExample instanceof Set); // true\nconsole.log(promiseExample instanceof Promise); // true\n```\n\n## instanceof 是什么\n\nMDN 定义：`instanceof` 是 JavaScript 的一个二元操作符，用于测试构造函数的 `prototype` 属性是否出现在对象的原型链中的任何位置。换句话说，`instanceof` 可以用于判断一个对象是否由某个构造函数创建的。\n\n```javascript\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\n\nconst auto = new Car(\"Honda\", \"Accord\", 1998);\nconsole.log(auto instanceof Car); // true\n```\n\n在这个例子中，auto 是 Car 的一个实例，所以 `auto instanceof Car` 返回 `true`。\n\n> 注意：左侧可以是任意类型，而右侧必须是一个函数的实例。参数错误时会报错。\n\n![参数要求.png](/post-assets/m46rsblg-参数要求.png)\n\n## instanceof 原理\n\n每个对象都有一个 `__proto__` 属性。在对象创建的时候会将 `__proto__` 属性指向它的构造函数的 `prototype` 属性上。并且构造函数的 `prototype` 属性本身也是一个对象。它也有自己的 `__proto__` 属性。通过 `__proto__` -> `prototype` 这样串联形成一个链条，这个链条就是原型链。原型链的终点是 `Object`，`Object.prototype.__proto__` 的值为 `null`。\n\n每个对象的构造函数都可以在原型链上找到，因此 `instanceof` 通过原型链可以判断对象是否由某个构造函数创建。\n\n![原型链.png](/post-assets/m46rsblj-原型链.png)\n\n## 实现一个 instanceof\n\n### 手写 instanceof\n\n手写 `instanceof` 的实现可以帮助我们更深入地理解 JavaScript 的原型链。下面是一个简易的 `instanceof` 实现：\n\n1. 参数校验\n2. 比较 `obj.__proto === constructor.prototype`\n  - 找到就立即返回 `true`\n  - 遍历到原型链终点 `constructor.prototype === null` 时，返回 `false`\n\n\n```javascript\nfunction myInstanceof(obj, constructor) {\n  const BASIC_TYPE = [\n    \"[object Undefined]\",\n    \"[object Null]\",\n    \"[object Number]\",\n    \"[object String]\",\n    \"[object Boolean]\",\n    \"[object Symbol]\",\n    \"[object BigInt]\",\n  ];\n\n  const objType = Object.prototype.toString.call(obj);\n  const constructorType = Object.prototype.toString.call(constructor);\n\n  if (BASIC_TYPE.includes(constructorType)) {\n    throw TypeError(\"Right-hand side of 'instanceof' is not an object\");\n  }\n  if (typeof constructor !== \"function\") {\n    throw TypeError(\"Right-hand side of 'instanceof' is not callable\");\n  }\n  if (BASIC_TYPE.includes(objType)) {\n    return false;\n  }\n\n  let objProto = Reflect.getPrototypeOf(obj);\n  while (objProto !== null) {\n    if (Object.is(objProto, constructor.prototype)) {\n      return true;\n    }\n    objProto = Reflect.getPrototypeOf(obj);\n  }\n  return false;\n}\n```\n\n> 当传入的参数是对象时，如果操作成功  `Reflect.getPrototypeOf(target)`  返回对象的原型，如果操作失败（比如，目标不是对象）则返回  `false`。\n\n### 测试结果\n\n![测试结果.png](/post-assets/m46rsbli-测试结果.png)\n\n## 总结\n\n本文介绍了 JavaScript 类型判断的方法。对 `instanceof` 的概念、用法和实现进行了介绍。\n\n## 资料\n\n- [instanceof - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)","src/content/posts/1708-implement-instanceof.mdx","5a8744b395526b0c","1708-implement-instanceof.mdx",true,"1708-vue3-compiler-macro",{id:25,data:27,body:33,filePath:34,digest:35,legacyId:36,deferredRender:24},{title:28,date:29,updatedAt:30,tags:31,draft:19},"Vue3 编译宏使用与原理",["Date","2020-10-23T13:19:02.000Z"],["Date","2024-12-13T10:07:53.938Z"],[32],"Vue","Vue3 编译宏是一种特殊的语法糖，用于简化组件选项的声明。它们可以在 `<script setup>` 中使用，并且会在编译阶段被处理。编译宏可以提供类型推断、运行时消除以及开发体验优化等功能。\n\n## 一、什么是编译宏\n\nVue3 编译宏是在代码**编译阶段处理的特殊指令或函数**。Vue3 的编译宏主要是为 `<script setup>` 语法设计的。编译宏不需要导入就可以直接使用，且会随着 `<script setup>` 的处理过程一同被编译掉。\n\n## 二、编译宏有什么用\n\n编译宏提供了一种更简洁的方式来编写和维护已有的配置。在 Vue3 中，编译宏主要有以下几个作用：\n\n1. **类型推断和检查**：宏可以提供类型安全，帮助开发者在编写代码时避免类型错误。\n2. **运行时消除**：在 Vue3 的 `<script setup>` 中，引入的宏在编译阶段处理后，最终生成的代码中可能不会包含这些宏。这意味着宏可以提供额外的功能，而不会增加运行时的开销。\n3. **代码重用和维护**：通过定义宏，可以在不同的组件中重用相同的逻辑。这有助于维护代码的一致性，并减少重复代码的编写。\n4. **简化配置**：某些宏可以用于简化 Vue 组件的配置，使得配置更加简洁明了。\n5. **优化开发体验**：宏可以减少样板文件，提供更简洁的语法，从而提高开发效率和体验。\n6. **高级功能**：一些宏可能提供高级功能，如自动注册组件、自动导入依赖等。\n\n## 三、常见的编译宏\n\nVue 3 引入了几个编译宏（Compile-time Macros）来提高性能和开发体验。这些宏在编译时会被转换为高效的代码。下面是主要的编译宏：\n\n1. `defineProps`\n  - 用于声明组件的 props\n  - 例如：`const props = defineProps(['title', 'likes'])`\n\n2. `defineEmits`\n  - 用于声明组件可能触发的事件\n  - 例如：`const emit = defineEmits(['change', 'delete'])`\n\n3. `defineExpose`\n  - 用于显式地指定哪些属性和方法可以被父组件访问\n  - 例如：`defineExpose({ method1, property1 })`\n\n4. `withDefaults`\n  - 用于为 `defineProps` 定义的 props 提供默认值\n  - 例如：`const props = withDefaults(defineProps<Props>(), { message: 'hello' })`\n\n5. `defineOptions`\n  - 用于定义组件选项，如 `name`、`inheritAttrs` 等\n  - 例如：`defineOptions({ name: 'MyComponent', inheritAttrs: false })`\n\n6. `defineSlots`\n  - 用于在使用 TypeScript 时为插槽定义类型\n  - 例如：`const slots = defineSlots<{ default: (props: { item: string }) => any }>()`\n\n7. `defineModel`\n  - 用于在 3.4+ 版本中简化 `v-model` 的使用\n  - 例如：`const model = defineModel<string>({ default: '' })`\n\n8. `defineAsyncComponent`\n  - 虽然不是编译宏，但它是一个用于定义异步组件的运行时辅助函数\n  - 例如：`const AsyncComp = defineAsyncComponent(() => import('./components/AsyncComponent.vue'))`\n\n\n这些编译宏主要用在 `<script setup>` 中，它们提供了更简洁的语法和更好的类型推断。使用这些宏可以减少样板代码，提高代码的可读性和维护性。\n\n## 四、编译宏的实现原理\n\n编译宏的本质就是在编译阶段执行的一个转化函数。它的工作原理如下：\n\n- 识别：编译器识别特定的宏调用（如 `defineProps()`）。\n- 分析：分析宏调用的参数和上下文。\n- 转换：将宏调用转换为适当的运行时代码或组件选项。\n- 类型生成：（在 TypeScript 环境中）生成相应的类型声明。\n- 代码生成：生成最终的 JavaScript 代码，通常会移除宏调用本身。\n\n![vue3-compile-macro.png](/post-assets/m4ml4fgx-vue3-compile-macro.png)\n\n### 1. 以 defineProps 为例子实现一个编译宏功能\n\n下面是一个 babel 插件的简单实现。它能将 Vue3 编译宏 `defineProps` 转换成 Vue 的 props 对象。从这个例子可以更好地理解编译宏语法糖的本质。\n\n```javascript\nconst { declare } = require('@babel/helper-plugin-utils');\nconst { types: t } = require('@babel/core');\n\nmodule.exports = declare(api => {\n  api.assertVersion(7); // 确保 Babel 版本兼容性\n\n  return {\n    name: \"babel-plugin-transform-define-props\",\n    visitor: {\n      CallExpression(path) {\n        // 检查是否是 defineProps 函数调用\n        if (path.node.callee.name === 'defineProps') {\n          const arg = path.node.arguments[0];\n          \n          if (t.isObjectExpression(arg)) {\n            // 处理对象语法: defineProps({ prop: String })\n            const properties = arg.properties.map(prop => {\n              // 将每个属性转换为 { prop: { type: PropType } } 的形式\n              return t.objectProperty(\n                prop.key,\n                t.objectExpression([\n                  t.objectProperty(t.identifier('type'), prop.value)\n                ])\n              );\n            });\n            \n            const propsObject = t.objectExpression(properties);\n            \n            // 将 defineProps 调用替换为 __props__ 赋值\n            path.replaceWith(\n              t.variableDeclaration('const', [\n                t.variableDeclarator(\n                  t.identifier('__props__'),\n                  propsObject\n                )\n              ])\n            );\n          } else if (t.isArrayExpression(arg)) {\n            // 处理数组语法: defineProps(['prop1', 'prop2'])\n            const properties = arg.elements.map(element => {\n              // 将每个元素转换为 { prop: null } 的形式\n              return t.objectProperty(element, t.identifier('null'));\n            });\n            \n            const propsObject = t.objectExpression(properties);\n            \n            // 将 defineProps 调用替换为 __props__ 赋值\n            path.replaceWith(\n              t.variableDeclaration('const', [\n                t.variableDeclarator(\n                  t.identifier('__props__'),\n                  propsObject\n                )\n              ])\n            );\n          }\n        }\n      }\n    }\n  };\n});\n```\n\n### 2. 转换效果\n\n```javascript\n// 转换前：对象语法\nconst props1 = defineProps({\n  name: String,\n  age: Number,\n  isActive: Boolean\n});\n\n// 转换后：对象语法转换结果\nconst __props__ = {\n  name: { type: String },\n  age: { type: Number },\n  isActive: { type: Boolean }\n};\n\n// 转换前：数组语法\nconst props2 = defineProps(['title', 'content']);\n\n// 转换后：数组语法转换结果\nconst __props__ = {\n  title: null,\n  content: null\n};\n```\n\n在编译时识别特定的代码模式，并将其转换为等效但可能更复杂或更优化的代码。在 Vue 的实际实现中，这个过程会更加复杂，包括处理类型推断、默认值、验证等多个方面。\n\n## 总结\n\n本文介绍了 Vue3 编译宏。编译宏是 Vue3 的一个强大特性，它们提供了更简洁的语法和更好的类型推断，使得组件编写更加高效和愉快。\n\n## 参考资料\n\n- [Vue3 官方文档](https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits)","src/content/posts/1708-vue3-compiler-macro.mdx","c71700622878a31b","1708-vue3-compiler-macro.mdx","2501-javascript-setTimeout-timeout",{id:37,data:39,body:44,filePath:45,digest:46,legacyId:47,deferredRender:24},{title:40,date:41,updatedAt:42,tags:43,draft:19},"setTimeout 最小延迟机制",["Date","2025-01-09T07:33:49.472Z"],["Date","2025-01-09T08:12:09.482Z"],[18],"## 引言\n\n在 JavaScript 中，`setTimeout` 是最常用的定时器 API 之一。然而，很多开发者可能并不了解，当我们设置一个理论上的\"0毫秒\"延迟时，实际上并不会为 0ms。在某些场景下实际执行时间甚至永远不会小于 4ms。这个看似奇怪的限制背后有着深层的技术原因和历史渊源。\n\n## 最小延迟值的演变\n\n### 历史变迁\n\n- 1995年：JavaScript 首次在 Netscape Navigator 中引入\n- 2003年：IE 实现了 15.625ms 的最小延迟\n- 2009年：Firefox 采用了 10ms 的限制\n- 2010年：HTML5 规范将嵌套层级大于等于 5 的场景的最小延迟标准化为 4ms，层级小于 5 的情况下最小延迟标准化为 0ms\n\n## 规范依据\n\n### HTML 规范\n\n根据 HTML Living Standard 规范：\n\n1. 如果设置的 `timeout` 小于 0，则设置为 0\n2. 如果嵌套的层级超过了 5 层，并且 timeout 小于 4ms，则设置 timeout 为 4ms。\n\n![image.png](/post-assets/m5p0iae8-image.png)\n\n### Chrome 源码分析\n\n在 Chromium 的源代码中，我们可以看到相关实现：\n\n```cpp\nstatic const int kMaxTimerNestingLevel = 5;\nstatic const double kMinimumInterval = 0.004; // 4ms\n```\n\n## 技术原理解析\n\n### 1. 事件循环与定时器\n\nJavaScript 的事件循环机制是理解 setTimeout 行为的关键。定时器不是一个真正的\"睡眠\"，而是将回调函数放入一个待执行队列。等到满足定时条件后，再执行回调函数。\n\n### 2. 最小延迟测算\n\n下面是一个测算 `setTimeout` 实际延迟时间的示例\n\n```javascript\n// 示例：嵌套定时器的行为\nfunction nestedTimer(depth = 0) {\n    const start = performance.now();\n    setTimeout(() => {\n        const delay = performance.now() - start;\n        console.log(`Depth ${depth}, Actual delay: ${delay}ms`);\n        if (depth < 10) nestedTimer(depth + 1);\n    }, 0);\n}\n```\n\n![image.png](/post-assets/m5p0iae7-image.png)\n\n**结果分析**\n\n当嵌套层数少于 5 层时，；理论延迟时间是 0ms；当嵌套层数大于等于 5 层时，理论延迟时间是 4ms（此处和 HTML 规范不一样）。但实际的执行延时受制于事件循环机制，`setTimeout` 回调需要等待：\n\n1. 当前同步代码执行完；\n2. 微任务队列情况\n3. 定时器到期\n4. 等待下一个宏任务执行时机\n5. 代码执行开销\n\n因此，实际的时延会比设置值向上浮动。但 timeout 值的下限是受到嵌套层级约束的。\n\n## 性能影响与优化\n\n### 1. CPU 和电池影响\n\n过于频繁的定时器调用会导致：\n\n- CPU 使用率上升\n- 设备发热增加\n- 电池寿命减少\n\n### 2. 替代方案\n\n对于需要高精度计时的场景，推荐使用：\n\n1. requestAnimationFrame\n\n```javascript\nrequestAnimationFrame(() => { \n\t// 用于动画的精确控制 \n});\n```\n\n1. Web Workers\n\n```javascript\n// worker.js \nsetInterval(() => { \n\tpostMessage('tick'); \n}, 0);\n```\n\n1. Performance.now()\n\n```javascript\nconst start = Performance.now(); // 用于精确计时\n```\n\n## 结论\n\nsetTimeout 的 4ms 最小延迟是一个经过深思熟虑的设计决策，它平衡了开发便利性、性能开销和浏览器兼容性。理解这个机制有助于我们写出更好的异步代码。\n\n## 参考资料\n\n- [HTML Standard](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout)\n- [为什么 setTimeout 有最小时延 4ms ?](https://mp.weixin.qq.com/s/4P7ohpRmBChXQpLC-MHgHQ)","src/content/posts/2501-javascript-setTimeout-timeout.mdx","bdb2da227ae61d6a","2501-javascript-setTimeout-timeout.mdx","2412-float-attribute-in-ios-android",{id:48,data:50,body:57,filePath:58,digest:59,legacyId:60,deferredRender:24},{title:51,date:52,updatedAt:53,tags:54,draft:19},"H5 中的浮点数渲染差异：iOS vs Android",["Date","2024-12-13T09:26:35.808Z"],["Date","2024-12-13T09:26:35.809Z"],[55,56],"Android","iOS","## **一、概述**\n\n移动端 H5 开发中，浮点数的渲染处理是一个常见但容易被忽视的问题。iOS 和 Android 平台由于底层渲染引擎的差异，对浮点数的处理存在明显不同。了解这些差异对于开发高质量的跨平台 H5 应用至关重要。\n\n## **二、渲染差异对比**\n\n### **1. 文字渲染**\n\n#### iOS (WebKit)\n\n- 行高强制对齐整数像素，如 14.3px 会被四舍五入为 14px\n- 字号会被四舍五入到最近的整数\n- 原因：CoreText 渲染引擎为保证文字清晰度，强制像素对齐\n\n```auto\n14.3px -> 14px\n14.7px -> 15px\n14.5px -> 15px\n```\n\n#### Android (Chromium)\n\n- 完整支持浮点数渲染\n- 可以实现精确的小数行高和字号\n- 使用 Skia 渲染引擎，支持亚像素渲染\n\n### **2. UI 元素**\n\n**共同支持浮点数的属性**\n\n- transform: 支持精确的小数值动画\n- opacity: 支持 0-1 之间的任意浮点数\n- position: 支持精确定位\n\n**平台特定行为**\n\niOS:\n\n- border: 强制对齐到整数像素\n- box-shadow: 支持浮点数但可能存在性能问题\n\nAndroid:\n\n- 几乎所有属性都支持浮点数\n- 渲染精度取决于设备的硬件能力\n\n## **三、产生差异的原因**\n\n### **1. 技术层面**\n\n- iOS CoreText 追求文字渲染的清晰度和一致性\n- Android Skia 更注重渲染的灵活性和精确性\n- 硬件加速实现方式的不同导致精度差异\n\n### **2. 历史原因**\n\n- Apple 一直强调用户体验的一致性\n- Android 的开放性导致更灵活的渲染策略\n\n## **四、开发建议**\n\n### **1. 通用处理方案**\n\n```javascript\n// 检测平台\nconst isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);\n\n// 行高处理\nconst getLineHeight = (value) => {\n  return isIOS ? Math.round(value) : value;\n};\n\n// 使用示例\nelement.style.lineHeight = `${getLineHeight(14.3)}px`;\n```\n\n### **2. 特殊场景处理**\n\n**动画效果**\n\n```javascript\n// 文字动画处理\nconst animateText = (element) => {\n  if (isIOS) {\n    // iOS 使用整数步进\n    element.style.transform = `translateY(${Math.round(value)}px)`;\n  } else {\n    // Android 可以使用浮点数\n    element.style.transform = `translateY(${value}px)`;\n  }\n};\n```\n\n**文字排版**\n\n```javascript\n/* 跨平台一致性处理 */\n.text {\n  /* 使用整数值避免差异 */\n  line-height: 20px;\n  font-size: 16px;\n  \n  /* 需要精确控制时使用 transform */\n  transform: translateY(0.5px);\n}\n```\n\n## 结论\n\n理解和妥善处理浮点数渲染差异，是开发高质量 H5 应用的重要环节。在实际开发中，应该根据具体场景选择合适的处理策略，在保证体验一致性的同时，也要充分利用各平台的特性。\n\n## 参考资料\n\n- [Developing Web Content for Safari](https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/Introduction/Introduction.html)\n- [Graphics and Skia](https://www.chromium.org/developers/design-documents/graphics-and-skia/)\n- [CSS Values and Units Module Level 3](https://www.w3.org/TR/css-values-3/)","src/content/posts/2412-float-attribute-in-ios-android.mdx","4dee7719dcc4722b","2412-float-attribute-in-ios-android.mdx","2504-sse",{id:61,data:63,body:70,filePath:71,digest:72,legacyId:73,deferredRender:24},{title:64,date:65,updatedAt:66,tags:67,draft:19,cover:69},"SSE 服务端推送",["Date","2025-04-03T07:35:49.000Z"],["Date","2025-12-01T09:28:48.190Z"],[68],"Network","/post-assets/m911icos-Pasted-image-20250402200626.png","## 引言\n\nServer-Sent Events (SSE) 是一种服务器推送技术，允许服务器向客户端实时推送数据。在以下场景特别有用：\n\n- 实时数据更新（如股票价格、天气信息）\n- 社交媒体信息流\n- 实时日志显示\n- 进度通知\n\n![Pasted image 20250402200626.png](/post-assets/m911icos-Pasted-image-20250402200626.png)\n\n## SSE 的本质\n\nSSE 本质上是基于 HTTP 协议的单向通信机制：\n\n- 使用 HTTP 长连接实现服务器到客户端的单向数据流\n- 数据格式为纯文本，编码必须是 UTF-8\n- 基于标准 HTTP 协议，无需特殊协议支持\n\n## SSE 的特点\n\n1. 单向通信：服务器到客户端的单向数据流\n2. 自动重连：断开后默认自动重连\n3. 简单易用：使用标准 HTTP，无需 WebSocket 的复杂配置\n4. 支持自定义事件\n5. 天然支持跨域（CORS）\n\n## SSE 客户端 API\n\n基本使用示例：\n\n```javascript\nconst evtSource = new EventSource('/events');\n\n// 监听消息\nevtSource.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    console.log(data);\n};\n\n// 监听连接打开\nevtSource.onopen = function() {\n    console.log('连接已建立');\n};\n\n// 监听错误\nevtSource.onerror = function(err) {\n    console.error('发生错误:', err);\n};\n\n// 监听自定义事件\nevtSource.addEventListener('custom-event', function(e) {\n    console.log('自定义事件:', e.data);\n});\n\n// 关闭连接\n// evtSource.close();\n```\n\n## SSE 服务端实现\n\n### 数据格式\n\n服务器发送的数据必须遵循特定格式：\n\n- 每条消息以 `data:` 开头\n- 每条消息以 `\\n\\n` 结尾\n- 支持多个字段：data、event、id、retry\n\n### data 字段\n\n```text\ndata: 消息内容\\n\\n\n```\n\n多行数据：\n\n```text\ndata: 第一行\\n\ndata: 第二行\\n\\n\n```\n\n### id 字段\n\n用于消息标识，断线重连时会发送 `Last-Event-ID` 头：\n\n```text\nid: 1\\n\ndata: 消息内容\\n\\n\n```\n\n### event 字段\n\n用于指定事件类型：\n\n```text\nevent: custom-event\\n\ndata: 消息内容\\n\\n\n```\n\n### retry 字段\n\n指定重连时间（毫秒）：\n\n```text\nretry: 10000\\n\ndata: 消息内容\\n\\n\n```\n\n## Node 服务器实例\n\n```javascript\nconst express = require('express');\nconst app = express();\n\napp.get('/events', (req, res) => {\n    // 设置 SSE 所需的 headers\n    res.writeHead(200, {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache',\n        'Connection': 'keep-alive'\n    });\n\n    // 发送初始数据\n    res.write('data: 连接已建立\\n\\n');\n\n    // 定时发送数据\n    const intervalId = setInterval(() => {\n        const data = {\n            time: new Date().toISOString(),\n            value: Math.random()\n        };\n        \n        res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n    }, 1000);\n\n    // 监听连接关闭\n    req.on('close', () => {\n        clearInterval(intervalId);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('SSE 服务器运行在 3000 端口');\n});\n```\n\n## 注意事项\n\n1. 格式有特定要求：开头为 `data:`、结尾为 `\\n\\n`\n2. 每个浏览器的并发 SSE 连接数有限制\n3. 某些代理服务器可能不支持长连接\n4. 建议实现错误重试机制\n5. 大规模使用时注意服务器资源管理\n\n## SSE 与 Websocket 的区别\n\n### **SSE**\n\nSSE 是基于传统的 HTTP 协议实现的，采用了长轮询（long-polling）机制。客户端通过向服务器发送一个 HTTP 请求，服务器保持连接打开并周期性地向客户端发送数据。\n\nSSE 通过 `EventSource` 对象来实现，在客户端可以通过监听 `onmessage` 事件来接收服务器端发送的数据。\n\n### **WebSocket**\n\nWebSocket 是基于独立的 TCP 连接实现的，使用自定义的协议。客户端和服务器之间可以建立持久的全双工通信的连接，可以双向发送和接收数据。\n\nWebSocket 协议是基于帧的，可以通过发送不同类型的帧进行通信。\n\n## 总结\n\nSSE 是一个简单但强大的服务器推送方案：\n\n- 相比 WebSocket 更轻量，实现更简单\n- 单向通信满足大多数推送场景\n- 基于 HTTP 协议，兼容性好\n- 自动重连机制提高可靠性\n\n适用场景：\n\n- 实时数据更新\n- 消息通知\n- 日志流式处理\n\n## 参考资料\n\n- [Server-Sent Events 教程 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\n- [高并发场景下，为什么大厂都选择SSE而不是WebSocket？](https://juejin.cn/post/7487831341591511067)","src/content/posts/2504-sse.mdx","3085be3d21fa8385","2504-sse.mdx","2504-cursor-figma-mcp",{id:74,data:76,body:82,filePath:83,digest:84,legacyId:85,deferredRender:24},{title:77,date:78,updatedAt:79,tags:80,draft:19},"Cursor 接入 Figma MCP",["Date","2025-04-01T07:33:49.472Z"],["Date","2025-04-03T07:32:36.809Z"],[81],"AI","## MCP\n\nMCP (Model Control Protocol) 是 Cursor 提供的一个协议，允许外部服务为 Cursor AI 提供额外的上下文信息。通过 Figma MCP，我们可以让 Cursor 直接读取 Figma 设计稿的信息，从而实现更精准的代码还原。\n\n![1.png](/post-assets/m8yazve0-1.png)\n\n## 环境配置\n\n### 启动 Figma MCP 服务器\n\n在 Figma 控制台获取到 figma-api-key（至少需要可读权限）。复制下来生成的 `api-key` 然后在终端执行命令。\n\n```shell\npnpx figma-developer-mcp --figma-api-key=<your-figma-api-key>\n```\n\n运行后，显示在本地 3333 端口启动 Figma MCP Server\n\n![2.jpg](/post-assets/m8yazve7-2.jpg)\n\n### Cursor MCP 配置\n\n在 Cursor 设置中添加 MCP 配置（Cursor Version: 0.47.8）\n\n![3.jpg](/post-assets/m8yazve4-3.jpg)\n\n在 `mcp.json` 中设置 Figma MCP Server 地址\n\n```json\n{ \n\t\"mcpServers\": { \n\t\t\"Figma\": { \n\t\t\t\"url\": \"http://localhost:3333/sse\" \n\t\t} \n\t} \n}\n```\n\n看到绿灯亮起就是说明配置成功\n\n![4.png](/post-assets/m8yazve6-4.png)\n\n## Figma MCP 使用\n\nFigma MCP 只是增强了 Cursor 的能力，使其具备了和 Figma 设计稿交互的能力。我们只需要在使用 Cursor 的过程中，将设计稿的信息附上。Cursor 就能够自动去获取目标元素的设计信息，更好地还原。\n\n![5.jpg](/post-assets/m8yazve6-5.jpg)\n\n在 Prompt 中附上 Figma Section URL 并指定需要写入的文件（开启 Agent 模式）\n\n![6.jpg](/post-assets/m8yazve6-6.jpg)\n\n![7.jpg](/post-assets/m8yazve7-7.jpg)\n\n### 还原效果\n\n从结果来看，还原效果比截图上传要好。\n\n![8.png](/post-assets/m8yazve7-8.png)\n\n## 注意事项\n\n1. Figma 文件需要具有适当的访问权限\n\n2. MCP 服务器需要保持运行状态，否则 Cursor 将无法获取设计信息\n\n3. 复制的 Figma Section URL 必须是具体元素的链接，而不是整个页面的链接\n\n4. 目前 MCP 主要支持基础的样式信息，复杂的交互效果可能需要手动调整\n\n## 总结\n\nFigma MCP 为 Cursor AI 提供了直接获取设计稿信息的能力，相比传统的截图上传方式，它能够：\n\n1. 更准确地获取颜色、尺寸、字体等样式信息\n\n2. 减少手动测量和调整的工作量\n\n3. 提高代码还原的效率和准确度\n\n这种工作流程特别适合前端开发团队，能够显著提升设计稿还原的效率。不过在使用过程中需要注意配置正确的权限和保持 MCP 服务器的稳定运行。","src/content/posts/2504-cursor-figma-mcp.mdx","43e139994fbcb71a","2504-cursor-figma-mcp.mdx","2507-claude-code-kimi-k2",{id:86,data:88,body:94,filePath:95,digest:96,legacyId:97,deferredRender:24},{title:89,date:90,updatedAt:91,tags:92,draft:19,cover:93},"Claude Code 中接入 Kimi K2 大模型",["Date","2025-07-17T09:39:21.783Z"],["Date","2025-07-17T09:44:32.159Z"],[81],"/post-assets/md774iew-image-20250717161529431.png","## 前言\n\nClaude Code 是 Anthropic 推出的 AI 编程助手，具备强大的代码生成与理解能力。然而，受限于国内网络环境，Claude Sonnet 4、Claude Opus 4 等模型的使用门槛较高。为此，本文介绍如何将 Claude Code 切换为月之暗面最新发布的 Kimi K2 大模型，实现无缝对接与高效开发。\n\n![image-20250717161529431.png](/post-assets/md774iew-image-20250717161529431.png)\n\n---\n\n## 环境准备\n\n1. **安装最新版 Node.js**\n\n请前往 [Node.js 官网](https://nodejs.org/)下载并安装。\n\n2. **安装 Claude Code**\n\n终端执行：`npm install -g @anthropic-ai/claude-code`\n\n3. **注册 Kimi API 平台账号并获取 API Key**\n\n- 打开 [Kimi API 平台](https://kimi.moonshot.cn/)，注册账号。\n- 登录后，新建 API Key。\n\n![image-20250717155709394.png](/post-assets/md774iey-image-20250717155709394.png)\n\n4. **充值升级账号（强烈建议）**\n\n免费版 Kimi API 限制较多，建议充值 50 元升级至 Tier1，解锁更高额度和更稳定的调用权限。\n\n![image-20250717155753583.png](/post-assets/md774iez-image-20250717155753583.png)\n\n## API Key 配置\n\n修改 Claude Code 的默认配置，使用自定义的模型能力。\n\n###   \nWindows\n\n在命令提示符中执行：\n\n```bash\nsetx ANTHROPIC_AUTH_TOKEN \"你的 API 密钥\"\nsetx ANTHROPIC_BASE_URL \"https://api.moonshot.cn/anthropic\"\n```\n\n### macOS / Linux\n\n根据所用终端类型，编辑对应配置文件：\n\n- Bash 用户：`~/.bashrc`\n- Zsh 用户：`~/.zshrc`\n\n添加如下内容：\n\n```bash\nexport ANTHROPIC_AUTH_TOKEN=你的API密钥\nexport ANTHROPIC_BASE_URL=https://api.moonshot.cn/anthropic\n```\n\n保存后，执行 `source ~/.zshrc` 或重启终端使配置生效。\n\n---\n\n## 启动与模型切换验证\n\n1. 进入项目目录，运行：`claude`\n\n2. 启动后，界面下方 Overrides 区域应显示 API Key 和 API Base 信息。\n\n![image-20250717155925831.png](/post-assets/md774iez-image-20250717155925831.png)\n\n3. 随便输入点啥（友情提示：每次输入都要花钱），只要 tokens 在跳动，恭喜你，模型已上线。\n\n![image-20250717160008829.png](/post-assets/md774iez-image-20250717160008829.png)\n\n![image-20250717161127189.png](/post-assets/md774iez-image-20250717161127189.png)\n\n> *界面写着 claude，其实背后已经是 kimi-k2-0711-preview 在默默搬砖。*\n\n---\n\n## 常见问题与排查\n\n**1.API Key 配置无效**：\n\n- 检查密钥是否有误，或是否已生效（重启终端/重新加载配置文件）。\n- 免费额度用尽或账号未充值也会导致调用失败。\n\n**2.无法切换模型：**\n\n- 确认 ANTHROPIC_BASE_URL 是否正确填写为 `https://api.moonshot.cn/anthropic`。\n\n**3.调用费用过高：**\n\n- 每次输入均计费，建议合理规划调用频率。\n\n---\n\n## Kimi K2 大模型的\"真香\"时刻\n\n1. **代码能力爆表**：\n\n- 各种榜单吊打 GPT-4.1、DeepSeek-V3，自动化、企业开发都不在话下。\n\n2. **超大上下文，记忆力惊人**：\n\n- 128k tokens，几十万字随便塞，长文档、老项目都能 hold 住。\n\n3. **价格感人，合规省心**：\n\n- 输入 1 美元/百万 tokens，输出 3 美元/百万 tokens，省下的钱可以多喝几杯咖啡。\n\n4. **生态丰富，接口友好**：\n\n- 兼容 Anthropic 协议，CLI、GUI、VSCode 插件全都能用。\n\n### 注意事项\n\n- API Key 属于敏感信息，请妥善保管，避免泄露。\n- 免费额度有限，建议及时充值以保证服务稳定。\n- 若需切换回 Claude 原生模型，只需恢复默认 ANTHROPIC_BASE_URL。\n- 费用按 tokens 计费，注意控制调用频率。\n\n---\n\n## 总结\n\n通过上述配置，即可在 Claude Code 中无缝接入 Kimi K2 大模型，享受高效、低成本的智能编程体验。Kimi K2 在代码生成、上下文处理、工程兼容性等方面均表现优异，是国内开发者的理想选择。","src/content/posts/2507-claude-code-kimi-k2.mdx","bd8d1a04462fca32","2507-claude-code-kimi-k2.mdx"];

export { _astro_dataLayerContent as default };
