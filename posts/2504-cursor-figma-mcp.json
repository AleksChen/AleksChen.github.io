{"__ud_title":"setTimeout 最小延迟机制","__ud_tags":["JavaScript"],"__ud_update_time":1736410329482,"__ud_create_time":1736408029472,"__ud_draft":false,"type":"doc","content":[{"type":"heading","attrs":{"level":1,"id":"setTimeout-最小延迟机制"},"content":[{"type":"text","text":"setTimeout 最小延迟机制"}]},{"type":"heading","attrs":{"level":2,"id":"引言"},"content":[{"type":"text","text":"引言"}]},{"type":"paragraph","content":[{"type":"text","text":"在 JavaScript 中，"},{"type":"text","marks":[{"type":"code"}],"text":"setTimeout"},{"type":"text","text":" 是最常用的定时器 API 之一。然而，很多开发者可能并不了解，当我们设置一个理论上的\"0毫秒\"延迟时，实际上并不会为 0ms。在某些场景下实际执行时间甚至永远不会小于 4ms。这个看似奇怪的限制背后有着深层的技术原因和历史渊源。"}]},{"type":"paragraph"},{"type":"heading","attrs":{"level":2,"id":"最小延迟值的演变"},"content":[{"type":"text","text":"最小延迟值的演变"}]},{"type":"heading","attrs":{"level":3,"id":"历史变迁"},"content":[{"type":"text","text":"历史变迁"}]},{"type":"bulletList","content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"1995年：JavaScript 首次在 Netscape Navigator 中引入"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"2003年：IE 实现了 15.625ms 的最小延迟"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"2009年：Firefox 采用了 10ms 的限制"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"2010年：HTML5 规范将嵌套层级大于等于 5 的场景的最小延迟标准化为 4ms，层级小于 5 的情况下最小延迟标准化为 0ms"}]}]}]},{"type":"paragraph"},{"type":"heading","attrs":{"level":2,"id":"规范依据"},"content":[{"type":"text","text":"规范依据"}]},{"type":"heading","attrs":{"level":3,"id":"HTML-规范"},"content":[{"type":"text","text":"HTML 规范"}]},{"type":"paragraph","content":[{"type":"text","text":"根据 HTML Living Standard 规范："}]},{"type":"orderedList","attrs":{"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"如果设置的 "},{"type":"text","marks":[{"type":"code"}],"text":"timeout"},{"type":"text","text":" 小于 0，则设置为 0"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"如果嵌套的层级超过了 5 层，并且 timeout 小于 4ms，则设置 timeout 为 4ms。"}]}]}]},{"type":"image","attrs":{"src":"/post-assets/m5p0iae8-image.png","alt":"image.png","title":null}},{"type":"heading","attrs":{"level":3,"id":"Chrome-源码分析"},"content":[{"type":"text","text":"Chrome 源码分析"}]},{"type":"paragraph","content":[{"type":"text","text":"在 Chromium 的源代码中，我们可以看到相关实现："}]},{"type":"codeBlock","attrs":{"language":"cpp"},"content":[{"type":"text","text":"static const int kMaxTimerNestingLevel = 5;\nstatic const double kMinimumInterval = 0.004; // 4ms"}]},{"type":"paragraph"},{"type":"heading","attrs":{"level":2,"id":"技术原理解析"},"content":[{"type":"text","text":"技术原理解析"}]},{"type":"heading","attrs":{"level":3,"id":"1-事件循环与定时器"},"content":[{"type":"text","text":"1. 事件循环与定时器"}]},{"type":"paragraph","content":[{"type":"text","text":"JavaScript 的事件循环机制是理解 setTimeout 行为的关键。定时器不是一个真正的\"睡眠\"，而是将回调函数放入一个待执行队列。等到满足定时条件后，再执行回调函数。"}]},{"type":"heading","attrs":{"level":3,"id":"2-最小延迟测算"},"content":[{"type":"text","text":"2. 最小延迟测算"}]},{"type":"paragraph","content":[{"type":"text","text":"下面是一个测算 "},{"type":"text","marks":[{"type":"code"}],"text":"setTimeout"},{"type":"text","text":" 实际延迟时间的示例"}]},{"type":"codeBlock","attrs":{"language":"javascript"},"content":[{"type":"text","text":"// 示例：嵌套定时器的行为\nfunction nestedTimer(depth = 0) {\n    const start = performance.now();\n    setTimeout(() => {\n        const delay = performance.now() - start;\n        console.log(`Depth ${depth}, Actual delay: ${delay}ms`);\n        if (depth < 10) nestedTimer(depth + 1);\n    }, 0);\n}"}]},{"type":"image","attrs":{"src":"/post-assets/m5p0iae7-image.png","alt":"image.png","title":null}},{"type":"paragraph","content":[{"type":"text","marks":[{"type":"bold"}],"text":"结果分析"}]},{"type":"paragraph","content":[{"type":"text","text":"当嵌套层数少于 5 层时，；理论延迟时间是 0ms；当嵌套层数大于等于 5 层时，理论延迟时间是 4ms（此处和 HTML 规范不一样）。但实际的执行延时受制于事件循环机制，"},{"type":"text","marks":[{"type":"code"}],"text":"setTimeout"},{"type":"text","text":" 回调需要等待："}]},{"type":"orderedList","attrs":{"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"当前同步代码执行完；"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"微任务队列情况"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"定时器到期"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"等待下一个宏任务执行时机"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"代码执行开销"}]}]}]},{"type":"paragraph","content":[{"type":"text","text":"因此，实际的时延会比设置值向上浮动。但 timeout 值的下限是受到嵌套层级约束的。"}]},{"type":"paragraph"},{"type":"heading","attrs":{"level":2,"id":"性能影响与优化"},"content":[{"type":"text","text":"性能影响与优化"}]},{"type":"heading","attrs":{"level":3,"id":"1-CPU-和电池影响"},"content":[{"type":"text","text":"1. CPU 和电池影响"}]},{"type":"paragraph","content":[{"type":"text","text":"过于频繁的定时器调用会导致："}]},{"type":"bulletList","content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"CPU 使用率上升"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"设备发热增加"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"电池寿命减少"}]}]}]},{"type":"heading","attrs":{"level":3,"id":"2-替代方案"},"content":[{"type":"text","text":"2. 替代方案"}]},{"type":"paragraph","content":[{"type":"text","text":"对于需要高精度计时的场景，推荐使用："}]},{"type":"orderedList","attrs":{"start":1},"content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"requestAnimationFrame"}]}]}]},{"type":"codeBlock","attrs":{"language":"javascript"},"content":[{"type":"text","text":"requestAnimationFrame(() => { \n\t// 用于动画的精确控制 \n});"}]},{"type":"orderedList","attrs":{"start":2},"content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"Web Workers"}]}]}]},{"type":"codeBlock","attrs":{"language":"javascript"},"content":[{"type":"text","text":"// worker.js \nsetInterval(() => { \n\tpostMessage('tick'); \n}, 0);"}]},{"type":"orderedList","attrs":{"start":3},"content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","text":"Performance.now()"}]}]}]},{"type":"codeBlock","attrs":{"language":"javascript"},"content":[{"type":"text","text":"const start = Performance.now(); // 用于精确计时"}]},{"type":"paragraph"},{"type":"heading","attrs":{"level":2,"id":"结论"},"content":[{"type":"text","text":"结论"}]},{"type":"paragraph","content":[{"type":"text","text":"setTimeout 的 4ms 最小延迟是一个经过深思熟虑的设计决策，它平衡了开发便利性、性能开销和浏览器兼容性。理解这个机制有助于我们写出更好的异步代码。"}]},{"type":"paragraph"},{"type":"heading","attrs":{"level":2,"id":"参考资料"},"content":[{"type":"text","text":"参考资料"}]},{"type":"bulletList","content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout","target":"_blank","rel":"noreferer","class":null}}],"text":"HTML Standard"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://mp.weixin.qq.com/s/4P7ohpRmBChXQpLC-MHgHQ","target":"_blank","rel":"noreferer","class":null}}],"text":"为什么 setTimeout 有最小时延 4ms ?"}]}]}]}]}