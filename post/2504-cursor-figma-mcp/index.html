<!DOCTYPE html> <html lang="en"> <head><meta charset="UTF-8"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Blog"><meta name="msapplication-TileColor" content="#000000"><meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><meta name="description" content="MCP (Model Control Protocol) 是 Cursor 提供的一个协议，允许外部服务为 Cursor AI 提供额外的上下文信息。通过 Figma MCP，我们可以让 Cursor 直接读取 Figma 设计稿的信息，从而实现更精准的代码还原。"><link rel="icon" href="/favicon.ico"><link rel="sitemap" href="/sitemap-index.xml"><title>Cursor 接入 Figma MCP | Blog</title><link rel="stylesheet" href="/_astro/_page_.CcehCa0K.css">
<style>.outlines a[data-anchor-tag=H1]{margin-left:0}.outlines a[data-anchor-tag=H2]{margin-left:12px}.outlines a[data-anchor-tag=H3]{margin-left:24px}.outlines a[data-anchor-tag=H4]{margin-left:36px}.outlines a[data-anchor-tag=H5]{margin-left:48px}.outlines a[data-anchor-tag=H6]{margin-left:60px}
._tabset_selm3_1 ._tab-panel_selm3_1{display:none}._tabset_selm3_1 ._tab-panels_selm3_4{display:flex}._tabset_selm3_1 input[data-tab-name=direct]{display:none}._tabset_selm3_1 input[data-tab-name=direct]:checked~._tab-panels_selm3_4 ._tab-panel_selm3_1[data-tab-name=direct]{display:block}._tabset_selm3_1 input[data-tab-name=direct]:checked~._tab-labels_selm3_13 label[data-tab-name=direct]{border-bottom:2px solid red}._tabset_selm3_1 input[data-tab-name=app]{display:none}._tabset_selm3_1 input[data-tab-name=app]:checked~._tab-panels_selm3_4 ._tab-panel_selm3_1[data-tab-name=app]{display:block}._tabset_selm3_1 input[data-tab-name=app]:checked~._tab-labels_selm3_13 label[data-tab-name=app]{border-bottom:2px solid red}
</style>
<link rel="stylesheet" href="/_astro/_page_.CBqBT8PC.css">
<link rel="stylesheet" href="/_astro/_id_.C16MaNET.css"><script type="module" src="/_astro/hoisted.BLJ_kEaE.js"></script></head> <body class="text-text bg-bg"> <header class="flex justify-between items-center p-4 gap-2 bg-gradient-to-r from-red-500 via-yellow-500 via-green-500 via-blue-500 to-purple yellow-500 text-white"> <a href="/" class="text-white text-lg" aria-label="homepage"> <div class="i-ri:home-4-line transition-transform hover:scale-120 active:scale-95"></div> </a> <div class="flex gap-2 items-center header-operations">   </div> </header>  <main> <div class="content"> <div class="w-full flex gap-2 pb-2"> <a href="/tag/AI" class="rounded hover:bg-gray-200 dark:hover:bg-modal px-3 py-1 cursor-pointer">
#AI </a> </div> <div class="ud-root read-only flex-1"><h1 level="1" id="Cursor-接入-Figma-MCP"><strong>Cursor 接入 Figma MCP</strong></h1><h2 level="2" id="MCP">MCP</h2><p>MCP (Model Control Protocol) 是 Cursor 提供的一个协议，允许外部服务为 Cursor AI 提供额外的上下文信息。通过 Figma MCP，我们可以让 Cursor 直接读取 Figma 设计稿的信息，从而实现更精准的代码还原。</p><img src="/post-assets/m8yazve0-1.png" alt="1.png"><p></p><h2 level="2" id="环境配置">环境配置</h2><h3 level="3" id="启动-Figma-MCP-服务器">启动 Figma MCP 服务器</h3><p>在 Figma 控制台获取到 figma-api-key（至少需要可读权限）。复制下来生成的&nbsp;<code>api-key</code>&nbsp;然后在终端执行命令。</p><div class="llt-code readonly"><div class="language">shell</div><div class="wrapper"><pre><code class="language-shell">pnpx figma-developer-mcp --figma-api-key=&lt;your-figma-api-key&gt;</code></pre></div></div><p>运行后，显示在本地 3333 端口启动 Figma MCP Server</p><img src="/post-assets/m8yazve7-2.jpg" alt="2.jpg"><p></p><h3 level="3" id="Cursor-MCP-配置">Cursor MCP 配置</h3><p>在 Cursor 设置中添加 MCP 配置（Cursor Version: 0.47.8）</p><img src="/post-assets/m8yazve4-3.jpg" alt="3.jpg"><p>在 <code>mcp.json</code> 中设置 Figma MCP Server 地址</p><div class="llt-code readonly"><div class="language">json</div><div class="wrapper"><pre><code class="language-json"><span class="hljs-punctuation" class="hljs-punctuation">{</span> 
	<span class="hljs-attr" class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation" class="hljs-punctuation">:</span> <span class="hljs-punctuation" class="hljs-punctuation">{</span> 
		<span class="hljs-attr" class="hljs-attr">&quot;Figma&quot;</span><span class="hljs-punctuation" class="hljs-punctuation">:</span> <span class="hljs-punctuation" class="hljs-punctuation">{</span> 
			<span class="hljs-attr" class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation" class="hljs-punctuation">:</span> <span class="hljs-string" class="hljs-string">&quot;http://localhost:3333/sse&quot;</span> 
		<span class="hljs-punctuation" class="hljs-punctuation">}</span> 
	<span class="hljs-punctuation" class="hljs-punctuation">}</span> 
<span class="hljs-punctuation" class="hljs-punctuation">}</span></code></pre></div></div><p>看到绿灯亮起就是说明配置成功</p><img src="/post-assets/m8yazve6-4.png" alt="4.png"><p></p><h2 level="2" id="Figma-MCP-使用">Figma MCP 使用</h2><p>Figma MCP 只是增强了 Cursor 的能力，使其具备了和 Figma 设计稿交互的能力。我们只需要在使用 Cursor 的过程中，将设计稿的信息附上。Cursor 就能够自动去获取目标元素的设计信息，更好地还原。</p><img src="/post-assets/m8yazve6-5.jpg" alt="5.jpg"><p>在 Prompt 中附上 Figma Section URL 并指定需要写入的文件（开启 Agent 模式）</p><img src="/post-assets/m8yazve6-6.jpg" alt="6.jpg"><img src="/post-assets/m8yazve7-7.jpg" alt="7.jpg"><p></p><h3 level="3" id="还原效果">还原效果</h3><p>从结果来看，还原效果比截图上传要好。</p><img src="/post-assets/m8yazve7-8.png" alt="8.png"><p></p><h2 level="2" id="注意事项">注意事项</h2><p>1. Figma 文件需要具有适当的访问权限</p><p>2. MCP 服务器需要保持运行状态，否则 Cursor 将无法获取设计信息</p><p>3. 复制的 Figma Section URL 必须是具体元素的链接，而不是整个页面的链接</p><p>4. 目前 MCP 主要支持基础的样式信息，复杂的交互效果可能需要手动调整</p><p></p><h2 level="2" id="总结">总结</h2><p>Figma MCP 为 Cursor AI 提供了直接获取设计稿信息的能力，相比传统的截图上传方式，它能够：</p><p>1. 更准确地获取颜色、尺寸、字体等样式信息</p><p>2. 减少手动测量和调整的工作量</p><p>3. 提高代码还原的效率和准确度</p><p>这种工作流程特别适合前端开发团队，能够显著提升设计稿还原的效率。不过在使用过程中需要注意配置正确的权限和保持 MCP 服务器的稳定运行。</p><p></p><script type="module">const injectHtml = (root, html) => {
  const iframe = document.createElement("iframe");
  const htmlContent = `<html><head></head><body>${html}</body></html>`;
  iframe.style.width = "100%";
  iframe.style.height = "100%";
  iframe.onload = () => {
    const doc = iframe.contentDocument || iframe.contentWindow?.document;
    if (!doc) {
      return;
    }
    doc.open();
    doc.write(htmlContent);
    doc.close();
  };
  root.replaceChildren(iframe);
}
  document.querySelectorAll('.playground')?.forEach(el=>{
    const html = el.getAttribute('data-html');
    if (html) {
      injectHtml(el,html);
    }
    const indicator = document.createElement("div");
    indicator.className = "indicator";
    const showCode = document.createElement("div");
    showCode.className = "show-code";
    showCode.innerText = "code";
    showCode.onclick = () => {
      el.parentElement.classList.remove("preview-only");
    };
    const showPreview = document.createElement("div");
    showPreview.className = "show-preview";
    showPreview.innerText = "preview";
    showPreview.onclick = () => {
      el.parentElement.classList.add("preview-only");
    };
    indicator.appendChild(showCode);
    indicator.appendChild(showPreview);
    el.parentElement.appendChild(indicator);
    if (window.screen.width < 768) {
      showPreview.click();
    }
  });</script></div> <div data-page-id="2504-cursor-figma-mcp" class="navigator flex justify-between items-center mt-4 py-4"> <a href="/post/2501-javascript-setTimeout-timeout" class="flex items-center gap-1 text-blue cursor-pointer flex-[45%]"> <div class="i-ri:arrow-left-double-line w-5 h-5 flex-shrink-0"></div> <div class="text-start">setTimeout 最小延迟机制</div> </a> <a href="/post/2504-sse" class="flex items-center justify-end gap-1 text-blue cursor-pointer flex-[45%]"> <div class="text-end">SSE 服务端推送</div> <div class="i-ri:arrow-right-double-line w-5 h-5 flex-shrink-0"></div> </a> </div> </div> <div class="outline-wrapper"></div> </main>  <footer class="mt-8 flex justify-center"> <small class="w-full max-w-[720px] min-h-12 flex justify-center items-center opacity-80"> <a href="https://github.com/AleksChen" target="_blank">© AleksChen</a> </small> </footer> </body></html>