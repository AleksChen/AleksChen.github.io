<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Blog"><meta name="msapplication-TileColor" content="#000000"><meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><link rel="icon" href="/favicon.ico"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/rss.xml"><title>
      Electron 小记 | Aleks
    </title><!-- 基础 SEO --><meta name="description" content="如果你是一个前端开发者，或者是刚接触编程的新手，你可能每天都在使用 VS Code 写代码，用 Discord 或 Slack 沟通，用 Notion 记笔记。你是否好奇过，为什么这些体验极佳的“桌面应用”，长得那么像网页？"><meta name="author" content="Aleks"><meta name="keywords" content="Electron, Native"><link rel="canonical" href="https://blog.002085.xyz//post/2512-electron-note"><!-- Open Graph --><meta property="og:type" content="article"><meta property="og:title" content="Electron 小记"><meta property="og:description" content="如果你是一个前端开发者，或者是刚接触编程的新手，你可能每天都在使用 VS Code 写代码，用 Discord 或 Slack 沟通，用 Notion 记笔记。你是否好奇过，为什么这些体验极佳的“桌面应用”，长得那么像网页？"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/electron/electron-original.svg"><meta property="og:url" content="https://blog.002085.xyz//post/2512-electron-note"><meta property="og:site_name" content="Aleks"><meta property="article:published_time" content="2025-12-23T19:54:00.000Z"><meta property="article:modified_time" content="2025-12-23T19:54:00.000Z"><meta property="article:tag" content="Electron"><meta property="article:tag" content="Native"><meta property="article:author" content="Aleks"><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Electron 小记"><meta name="twitter:description" content="如果你是一个前端开发者，或者是刚接触编程的新手，你可能每天都在使用 VS Code 写代码，用 Discord 或 Slack 沟通，用 Notion 记笔记。你是否好奇过，为什么这些体验极佳的“桌面应用”，长得那么像网页？"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/electron/electron-original.svg"><!-- JSON-LD 结构化数据 --><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Electron 小记","description":"如果你是一个前端开发者，或者是刚接触编程的新手，你可能每天都在使用 VS Code 写代码，用 Discord 或 Slack 沟通，用 Notion 记笔记。你是否好奇过，为什么这些体验极佳的“桌面应用”，长得那么像网页？","image":"https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/electron/electron-original.svg","datePublished":"2025-12-23T19:54:00.000Z","dateModified":"2025-12-23T19:54:00.000Z","author":{"@type":"Person","name":"Aleks"},"publisher":{"@type":"Organization","name":"Aleks","logo":{"@type":"ImageObject","url":"https://blog.002085.xyz/favicon.ico"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.002085.xyz//post/2512-electron-note"},"keywords":"Electron, Native"}</script><!-- <script async src="https://www.googletagmanager.com/gtag/js?id=G-G1EC4WNBZJ"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-G1EC4WNBZJ");
    </script> --><!-- Privacy-friendly analytics by Plausible --><script async src="https://plausible.io/js/pa-bqrNOvlYoay2S1opDAt9D.js"></script><script type="module">let e=window.scrollY;const t=document.getElementById("main-header");window.addEventListener("scroll",()=>{const l=window.scrollY;t&&(l<e||l<=100?t.classList.remove("-translate-y-full"):l>100&&l>e&&t.classList.add("-translate-y-full"),e=l)});</script><script>
      // 暗色模式初始化
      const theme = (() => {
        if (
          typeof localStorage !== "undefined" &&
          localStorage.getItem("theme")
        ) {
          return localStorage.getItem("theme");
        }
        if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
          return "dark";
        }
        return "light";
      })();

      if (theme === "dark") {
        document.documentElement.classList.add("dark");
      } else {
        document.documentElement.classList.remove("dark");
      }

      window.localStorage.setItem("theme", theme);
    </script><link rel="stylesheet" href="/assets/about.CoOOpYAR.css">
<link rel="stylesheet" href="/assets/index.DI2Kqa3G.css">
<style>@media(min-width:1024px){.layout-grid-cols[data-astro-cid-ztig7rse]{grid-template-columns:minmax(0,1fr) 240px}}
</style></head> <body class="bg-bg text-text min-h-screen flex flex-col font-sans transition-colors duration-300">  <header id="main-header" class="sticky top-0 z-50 w-full bg-bg border-b-2 border-text transition-transform duration-300"> <div class="max-w-[800px] mx-auto px-4 h-16 flex items-center justify-between"> <a href="/" class="text-xl font-bold flex items-center gap-2 hover:text-primary transition-colors" aria-label="homepage"> <div class="i-ri:home-4-line w-6 h-6"></div> </a> <div class="flex items-center gap-4"> <nav class="hidden md:flex items-center gap-6"> <a href="/archives" class="text-sm font-medium hover:text-primary transition-colors">
归档
</a> <a href="/tags" class="text-sm font-medium hover:text-primary transition-colors">
标签
</a> <a href="/about" class="text-sm font-medium hover:text-primary transition-colors">
关于
</a> </nav>  <div class="flex items-center gap-3 pl-4 border-l border-text"> <a href="https://github.com/AleksChen" target="_blank" class="hover:text-primary transition-transform hover:scale-110" title="GitHub"> <div class="i-ri:github-fill w-6 h-6"></div> </a> <button id="theme-toggle" class="hover:text-primary transition-transform hover:scale-110 focus:outline-none" title="Toggle Theme"> <div class="i-ri:sun-line w-6 h-6 dark:hidden"></div> <div class="i-ri:moon-line w-6 h-6 hidden dark:block"></div> </button> </div> </div> </div> </header> <main class="flex-1 w-full mx-auto px-4 py-8 animate-fade-in max-w-[1200px]">  <div class="grid grid-cols-1 gap-8 items-start layout-grid-cols" data-astro-cid-ztig7rse> <article class="w-full min-w-0 bg-card p-4 md:p-8 rounded-lg border-2 border-text shadow-[4px_4px_0_0_var(--color-text)]" data-astro-cid-ztig7rse>  <header class="mb-8 pb-8 border-b border-border" data-astro-cid-ztig7rse> <div class="flex flex-wrap gap-2 mb-4" data-astro-cid-ztig7rse> <a href="/tag/Electron" class="px-2 py-1 text-xs font-bold rounded-sm border border-text text-text bg-transparent shadow-[2px_2px_0_0_var(--color-text)] hover:translate-y-[1px] hover:translate-x-[1px] hover:shadow-none transition-all" data-astro-cid-ztig7rse>
#Electron </a><a href="/tag/Native" class="px-2 py-1 text-xs font-bold rounded-sm border border-text text-text bg-transparent shadow-[2px_2px_0_0_var(--color-text)] hover:translate-y-[1px] hover:translate-x-[1px] hover:shadow-none transition-all" data-astro-cid-ztig7rse>
#Native </a> </div> <h1 class="text-3xl md:text-4xl font-bold mb-4 leading-tight text-text" data-astro-cid-ztig7rse> Electron 小记 </h1> <div class="flex items-center gap-4 text-sm text-text-muted" data-astro-cid-ztig7rse> <time datetime="2025-12-23T19:54:00.000Z" class="flex items-center gap-1" data-astro-cid-ztig7rse> <div class="i-ri:calendar-line" data-astro-cid-ztig7rse></div> 12/23/2025 </time> <span class="flex items-center gap-1" title="最后更新时间" data-astro-cid-ztig7rse> <div class="i-ri:time-line" data-astro-cid-ztig7rse></div> 12/23/2025 </span> </div> </header>  <div class="prose prose-lg dark:prose-invert max-w-none break-words prose-a:text-primary prose-a:no-underline hover:prose-a:underline prose-headings:scroll-mt-24" data-astro-cid-ztig7rse> <h1 id="桌面开发的范式electron-小记">桌面开发的范式：Electron 小记</h1>
<h2 id="1-序幕为什么我们需要-electron">1. 序幕：为什么我们需要 Electron？</h2>
<p>如果你是一个前端开发者，或者是刚接触编程的新手，你可能每天都在使用 VS Code 写代码，用 Discord 或 Slack 沟通，用 Notion 记笔记。你是否好奇过，为什么这些体验极佳的“桌面应用”，长得那么像网页？</p>
<p>答案是：<strong>它们本质上就是网页。</strong></p>
<p>这就是 <strong>Electron</strong> 的魔法。</p>
<h3 id="11-跨平台开发的痛点">1.1 跨平台开发的痛点</h3>
<p>在 Electron 出现之前，开发一个同时能在 Windows、macOS 和 Linux 上运行的桌面软件，简直是噩梦：</p>
<ul>
<li><strong>Windows</strong>: 需要学 C# (.NET) 或 C++。</li>
<li><strong>macOS</strong>: 需要学 Objective-C 或 Swift。</li>
<li><strong>Linux</strong>: 需要学 C++ (Qt/GTK)。</li>
</ul>
<p>这意味着开发成本要乘以 3。而 Web 技术（HTML/CSS/JS）拥有全球最庞大的开发者群体，且界面迭代速度极快。</p>
<h3 id="12-electron-的诞生与核心价值">1.2 Electron 的诞生与核心价值</h3>
<p>GitHub 为了打造 Atom 编辑器（VS Code 的前身），创造了 Electron。它的核心理念非常简单粗暴：</p>
<blockquote>
<p><strong>把 Chrome 浏览器和 Node.js 打包在一起，装进一个盒子里。</strong></p>
</blockquote>
<ul>
<li><strong>Chromium</strong>：负责展示漂亮的界面（UI）。</li>
<li><strong>Node.js</strong>：负责接触底层系统（读写文件、网络通信）。</li>
</ul>
<p>于是，Web 开发者可以直接用自己熟悉的 JavaScript，画出原生级别的桌面应用。</p>
<hr/>
<h2 id="2-核心架构揭秘-electron-的运行机制">2. 核心架构：揭秘 Electron 的运行机制</h2>
<p>Electron 并不是把网页简单地“套壳”。它设计了一套独特的<strong>多进程架构</strong>，这稍微有点复杂，但我们用一个比喻来理解。</p>
<p>想象 Electron 是一个<strong>公司</strong>：</p>
<ol>
<li><strong>主进程 (Main Process) —— 公司 CEO</strong>
<ul>
<li><strong>数量</strong>：只有一个。</li>
<li><strong>职责</strong>：拥有最高权限。它负责招聘员工（创建窗口）、管理公司资源（文件系统、菜单栏、系统托盘）、处理由于生老病死带来的突发状况（生命周期管理）。</li>
<li><strong>能力</strong>：基于 Node.js，可以随意操作电脑底层。</li>
</ul>
</li>
<li><strong>渲染进程 (Renderer Process) —— 部门员工</strong>
<ul>
<li><strong>数量</strong>：每个窗口（Web 页面）就是一个员工，可以有多个。</li>
<li><strong>职责</strong>：只负责把界面画得好看（HTML/CSS/JS 渲染）。</li>
<li><strong>能力</strong>：基于 Chromium，为了安全，通常被限制在一个“沙盒”里，不能随意读写电脑文件。</li>
</ul>
</li>
</ol>
<h3 id="21-它们怎么沟通ipc-机制">2.1 它们怎么沟通？(IPC 机制)</h3>
<p>CEO 和员工不在同一个房间（进程隔离），不能直接对话。他们必须通过一条特殊的<strong>内部电话线</strong>来沟通，这就是 <strong>IPC (进程间通信)</strong>。</p>
<ul>
<li><strong>IPC Main</strong>: 主进程端的电话。</li>
<li><strong>IPC Renderer</strong>: 渲染进程端的电话。</li>
</ul>
<p><figure class="my-6 flex flex-col items-center"> <img src="/post-assets/2512-electron-note/IPC%20%E9%80%9A%E4%BF%A1.jpg" alt class="rounded-lg shadow-sm border border-border max-w-full h-auto" loading="lazy">  </figure></p>
<h3 id="22-示例代码">2.2 示例代码</h3>
<p>为了安全，现在官方推荐使用 <code>ContextBridge</code>。这就像在员工和 CEO 之间设立一个“传达室”，防止外部黑客通过网页直接控制 CEO。</p>
<ol>
<li>
<p><strong>主进程 (CEO)</strong>: 监听请求。</p>
<div class="code-block relative group my-6 overflow-hidden">  <div class="relative"> <pre class="astro-code astro-code-themes github-light one-dark-pro !my-0 !p-4 overflow-x-auto custom-scrollbar text-sm leading-relaxed !bg-transparent" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// main.js</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD">const</span><span style="color:#24292E;--shiki-dark:#ABB2BF"> { </span><span style="color:#005CC5;--shiki-dark:#E5C07B">ipcMain</span><span style="color:#24292E;--shiki-dark:#ABB2BF"> } </span><span style="color:#D73A49;--shiki-dark:#56B6C2">=</span><span style="color:#6F42C1;--shiki-dark:#61AFEF"> require</span><span style="color:#24292E;--shiki-dark:#ABB2BF">(</span><span style="color:#032F62;--shiki-dark:#98C379">&quot;electron&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="color:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// 监听 &#39;get-system-info&#39; 请求</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E5C07B">ipcMain</span><span style="color:#24292E;--shiki-dark:#ABB2BF">.</span><span style="color:#6F42C1;--shiki-dark:#61AFEF">handle</span><span style="color:#24292E;--shiki-dark:#ABB2BF">(</span><span style="color:#032F62;--shiki-dark:#98C379">&quot;get-system-info&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF">, </span><span style="color:#D73A49;--shiki-dark:#C678DD">async</span><span style="color:#24292E;--shiki-dark:#ABB2BF"> () </span><span style="color:#D73A49;--shiki-dark:#C678DD">=&gt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF"> {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD">  return</span><span style="color:#24292E;--shiki-dark:#ABB2BF"> { </span><span style="color:#24292E;--shiki-dark:#E06C75">platform</span><span style="color:#24292E;--shiki-dark:#ABB2BF">: </span><span style="color:#24292E;--shiki-dark:#E5C07B">process</span><span style="color:#24292E;--shiki-dark:#ABB2BF">.</span><span style="color:#24292E;--shiki-dark:#E06C75">platform</span><span style="color:#24292E;--shiki-dark:#ABB2BF"> };</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF">});</span></span></code></pre> <button class="copy-btn absolute top-2 right-2 z-50 flex items-center gap-1.5 px-2 py-1 rounded bg-white/20 dark:bg-white/5 text-xs text-white hover:bg-primary/10 dark:hover:bg-white/15 transition-colors cursor-pointer opacity-0 group-hover:opacity-100" aria-label="Copy code"> <div class="i-ri:file-copy-line text-sm"></div> <span>Copy</span> </button> </div> </div> <script type="module">function c(){document.querySelectorAll(".copy-block-init").forEach(e=>e.remove()),document.querySelectorAll(".code-block").forEach(e=>{if(e.hasAttribute("data-copy-init"))return;e.setAttribute("data-copy-init","true");const i=e.querySelector(".copy-btn");i&&i.addEventListener("click",async()=>{const o=e.querySelector("code");if(!o)return;const n=o.innerText;try{await navigator.clipboard.writeText(n);const t=i.querySelector("div"),r=i.querySelector("span");t&&(t.className="i-ri:check-line text-blue-500 text-sm"),r&&(r.innerText="Copied!",r.className="text-blue-500"),setTimeout(()=>{t&&(t.className="i-ri:file-copy-line text-sm"),r&&(r.innerText="Copy",r.className="")},2e3)}catch(t){console.error("Failed to copy:",t)}})})}document.addEventListener("astro:page-load",c);c();</script>
</li>
<li>
<p><strong>预加载脚本 (传达室)</strong>: 暴露安全的方法。</p>
<div class="code-block relative group my-6 overflow-hidden">  <div class="relative"> <pre class="astro-code astro-code-themes github-light one-dark-pro !my-0 !p-4 overflow-x-auto custom-scrollbar text-sm leading-relaxed !bg-transparent" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// preload.js</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD">const</span><span style="color:#24292E;--shiki-dark:#ABB2BF"> { </span><span style="color:#005CC5;--shiki-dark:#E5C07B">contextBridge</span><span style="color:#24292E;--shiki-dark:#ABB2BF">, </span><span style="color:#005CC5;--shiki-dark:#E5C07B">ipcRenderer</span><span style="color:#24292E;--shiki-dark:#ABB2BF"> } </span><span style="color:#D73A49;--shiki-dark:#56B6C2">=</span><span style="color:#6F42C1;--shiki-dark:#61AFEF"> require</span><span style="color:#24292E;--shiki-dark:#ABB2BF">(</span><span style="color:#032F62;--shiki-dark:#98C379">&quot;electron&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="color:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// 给网页暴露一个叫 electronAPI 的对象</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E5C07B">contextBridge</span><span style="color:#24292E;--shiki-dark:#ABB2BF">.</span><span style="color:#6F42C1;--shiki-dark:#61AFEF">exposeInMainWorld</span><span style="color:#24292E;--shiki-dark:#ABB2BF">(</span><span style="color:#032F62;--shiki-dark:#98C379">&quot;electronAPI&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF">, {</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#61AFEF">  getStats</span><span style="color:#24292E;--shiki-dark:#ABB2BF">: () </span><span style="color:#D73A49;--shiki-dark:#C678DD">=&gt;</span><span style="color:#24292E;--shiki-dark:#E5C07B"> ipcRenderer</span><span style="color:#24292E;--shiki-dark:#ABB2BF">.</span><span style="color:#6F42C1;--shiki-dark:#61AFEF">invoke</span><span style="color:#24292E;--shiki-dark:#ABB2BF">(</span><span style="color:#032F62;--shiki-dark:#98C379">&quot;get-system-info&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF">),</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF">});</span></span></code></pre> <button class="copy-btn absolute top-2 right-2 z-50 flex items-center gap-1.5 px-2 py-1 rounded bg-white/20 dark:bg-white/5 text-xs text-white hover:bg-primary/10 dark:hover:bg-white/15 transition-colors cursor-pointer opacity-0 group-hover:opacity-100" aria-label="Copy code"> <div class="i-ri:file-copy-line text-sm"></div> <span>Copy</span> </button> </div> </div> 
</li>
<li>
<p><strong>渲染进程 (员工)</strong>: 调用方法。</p>
<div class="code-block relative group my-6 overflow-hidden">  <div class="relative"> <pre class="astro-code astro-code-themes github-light one-dark-pro !my-0 !p-4 overflow-x-auto custom-scrollbar text-sm leading-relaxed !bg-transparent" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">// renderer.js</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD">const</span><span style="color:#005CC5;--shiki-dark:#E5C07B"> info</span><span style="color:#D73A49;--shiki-dark:#56B6C2"> =</span><span style="color:#D73A49;--shiki-dark:#C678DD"> await</span><span style="color:#24292E;--shiki-dark:#E5C07B"> window</span><span style="color:#24292E;--shiki-dark:#ABB2BF">.</span><span style="color:#24292E;--shiki-dark:#E5C07B">electronAPI</span><span style="color:#24292E;--shiki-dark:#ABB2BF">.</span><span style="color:#6F42C1;--shiki-dark:#61AFEF">getStats</span><span style="color:#24292E;--shiki-dark:#ABB2BF">();</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E5C07B">console</span><span style="color:#24292E;--shiki-dark:#ABB2BF">.</span><span style="color:#6F42C1;--shiki-dark:#61AFEF">log</span><span style="color:#24292E;--shiki-dark:#ABB2BF">(</span><span style="color:#24292E;--shiki-dark:#E06C75">info</span><span style="color:#24292E;--shiki-dark:#ABB2BF">);</span></span></code></pre> <button class="copy-btn absolute top-2 right-2 z-50 flex items-center gap-1.5 px-2 py-1 rounded bg-white/20 dark:bg-white/5 text-xs text-white hover:bg-primary/10 dark:hover:bg-white/15 transition-colors cursor-pointer opacity-0 group-hover:opacity-100" aria-label="Copy code"> <div class="i-ri:file-copy-line text-sm"></div> <span>Copy</span> </button> </div> </div> 
</li>
</ol>
<p><figure class="my-6 flex flex-col items-center"> <img src="/post-assets/2512-electron-note/contentBridge.jpg" alt class="rounded-lg shadow-sm border border-border max-w-full h-auto" loading="lazy">  </figure></p>
<div class="mermaid">graph TD
    subgraph MainProcess [&quot;主进程 (Node.js)&quot;]
        MainScript[&quot;主脚本 (Main Script)<br/>«核心控制»&quot;]
        NativeAPI[&quot;原生 API<br/>«系统能力»&quot;]
        WindowManager[&quot;窗口管理<br/>«业务逻辑»&quot;]
    end

    IPC((&quot;IPC 通信通道&quot;))

    subgraph RendererA [&quot;渲染进程 A (Chromium)&quot;]
        PageA[&quot;Web 页面 A<br/>«用户界面»&quot;]
        PreloadA[&quot;预加载脚本 A (Preload)<br/>«桥接层»&quot;]
    end

    subgraph RendererB [&quot;渲染进程 B (Chromium)&quot;]
        PageB[&quot;Web 页面 B<br/>«用户界面»&quot;]
        PreloadB[&quot;预加载脚本 B (Preload)<br/>«桥接层»&quot;]
    end

    subgraph OS [&quot;操作系统 (OS)&quot;]
        FileSystem[(&quot;文件系统&quot;)]
        Network[(&quot;网络&quot;)]
        NativeGUI[(&quot;原生 GUI&quot;)]
    end

    %% 关系连接
    MainScript &lt;--&gt; IPC
    IPC &lt;--&gt; PreloadA
    IPC &lt;--&gt; PreloadB

    MainScript --&gt; NativeAPI
    NativeAPI --- OS
    PageA -. &quot;Context Bridge (上下文桥接)&quot; .-&gt; PreloadA
    PageB -. &quot;Context Bridge (上下文桥接)&quot; .-&gt; PreloadB</div>
<hr/>
<h2 id="3-设计考量">3. 设计考量</h2>
<h3 id="31-隔离安全与性能">3.1 隔离安全与性能</h3>
<p>如果 Chrome 也是单进程的，这意味着只要你打开的一个网页崩溃了，整个浏览器就会闪退。Electron 同理：</p>
<ul>
<li><strong>渲染进程崩溃</strong>：只是当前窗口白屏，主程序还在，可以尝试刷新恢复。</li>
<li><strong>主进程崩溃</strong>：那是真的“全剧终”，整个应用退出。</li>
</ul>
<h3 id="32-赋予-web-原生超能力">3.2 赋予 Web 原生超能力</h3>
<p>普通的浏览器网页无法读取你电脑上的 <code>C:\Users\Documents</code>。但 Electron 通过 Node.js 打破了这个限制。</p>
<p>下面的流程图展示了 Web 页面是如何一步步获取到操作系统的文件的：</p>
<div class="mermaid">sequenceDiagram
    autonumber
    title Electron 获取原生能力逻辑流

    participant UI as 渲染层 (JS/HTML)
    participant Preload as 预加载脚本 (Preload)
    participant IPCR as IPC (渲染端)
    participant IPCM as IPC (主进程端)
    participant Main as 主进程 (Node.js)
    participant OS as 系统 API / 原生库

    UI-&gt;&gt;Preload: 调用暴露的方法 (例如: selectFile())
    Preload-&gt;&gt;IPCR: ipcRenderer.invoke(&#39;select-file&#39;)
    IPCR-&gt;&gt;IPCM: 发送异步消息 (Mojo/Pipe)
    IPCM-&gt;&gt;Main: 触发 ipcMain.handle 监听器
    Main-&gt;&gt;OS: 调用 Node.js fs 模块或 Electron dialog API
    OS--&gt;&gt;Main: 返回执行结果 (文件路径/数据)
    Main--&gt;&gt;IPCM: 返回 Promise 结果
    IPCM--&gt;&gt;IPCR: 跨进程回传数据
    IPCR--&gt;&gt;Preload: 得到结果
    Preload--&gt;&gt;UI: 回调更新界面</div>
<h3 id="33-事件循环的融合">3.3 事件循环的融合</h3>
<p>Electron 最厉害的技术难点之一，是将 Node.js 的事件循环（Libuv）和 Chromium 的事件循环（MessageLoop）融合在一起。如果不融合，UI 渲染的时候 Node.js 就会卡住，反之亦然。</p>
<div class="mermaid">sequenceDiagram
    title Node.js 与 Chromium 事件循环集成

    box &quot;Electron 运行环境&quot; #e6f3ff
        participant CML as Chromium 消息循环
        participant Bridge as Electron 桥接层
        participant UV as Node.js Libuv 循环
    end

    participant OS as 系统事件 (I/O, 定时器, UI)

    OS-&gt;&gt;CML: 捕获系统事件 (鼠标点击/绘制)
    CML-&gt;&gt;CML: 处理 Web 渲染逻辑

    loop 轮询集成 (Polling Integration)
        CML-&gt;&gt;Bridge: 检查 Node.js 任务状态
        Bridge-&gt;&gt;UV: 询问: &quot;有待处理的异步任务吗?&quot;
        UV-&gt;&gt;UV: 处理文件 I/O、网络请求、定时器
        UV--&gt;&gt;Bridge: 返回结果/回调
        Bridge-&gt;&gt;CML: 将 Node 回调注入消息队列
    end

    CML-&gt;&gt;OS: 更新 UI / 执行系统响应</div>
<hr/>
<h2 id="4-electron-的局限">4. Electron 的局限</h2>
<p>虽然 Electron 开发爽，但它也不是完美的。</p>
<h3 id="41-内存杀手">4.1 “内存杀手”</h3>
<p>每个 Electron 应用都相当于带了一个迷你版的 Chrome 浏览器。</p>
<ul>
<li><strong>体积大</strong>：哪怕写一个 Hello World，打包出来也得 100MB+。</li>
<li><strong>吃内存</strong>：多开几个 Electron 应用（VS Code + Slack + Notion），你的内存条就开始尖叫了。</li>
</ul>
<h3 id="42-安全性风险">4.2 安全性风险</h3>
<p>早期开发者为了图方便，喜欢开启 <code>nodeIntegration: true</code>。这相当于把自家的钥匙直接挂在门把手上。如果你的应用加载了一个恶意网页，黑客可以用一行 JS 代码删光你的硬盘。
<strong>现在的最佳实践是：默认关闭 Node 集成，使用 Context Isolation（上下文隔离）。</strong></p>
<h3 id="43-体验对比表">4.3 体验对比表</h3>



































<div class="table-container my-6 w-full overflow-x-auto"> <table class="w-full text-left border-collapse"> <thead><tr><th>指标</th><th>Electron</th><th>Tauri</th><th>原生开发 (Native)</th></tr></thead><tbody><tr><td><strong>安装包大小</strong></td><td>~150MB+ (胖)</td><td>~10MB (瘦)</td><td>&lt; 5MB (精)</td></tr><tr><td><strong>内存占用</strong></td><td>~100MB+</td><td>~30MB</td><td>&lt; 20MB</td></tr><tr><td><strong>UI 渲染</strong></td><td>Chromium 内核</td><td>调用系统自带 WebView</td><td>操作系统原生引擎</td></tr><tr><td><strong>开发语言</strong></td><td>JS / TS</td><td>Rust + JS</td><td>C++ / Swift / C#</td></tr></tbody> </table> </div>
<blockquote>
<p><strong>那么，什么情况下不应该用 Electron？</strong></p>
<ul>
<li><strong>轻量级工具</strong>：如果你只是想做一个简单的计算器或便签，为了这点功能塞进 150MB 的体积简直是杀鸡用牛刀。</li>
<li><strong>对性能极其敏感</strong>：比如高频交易软件、大型 3D 游戏，原生开发依然是王道。</li>
<li><strong>老旧硬件</strong>：如果你的目标用户还在用 4GB 内存的电脑，Electron 应用会让他们非常痛苦。</li>
</ul>
</blockquote>
<hr/>
<h2 id="5-electron-的演进方向">5. Electron 的演进方向</h2>
<h3 id="51-asar一种特殊的归档格式">5.1 ASAR：一种特殊的归档格式</h3>
<p>Electron 应用通常由成千上万个小的 JavaScript、CSS 和 HTML 文件组成。在分发应用时，Electron 默认使用 <strong>ASAR (Atom Shell Archive)</strong> 格式将这些源码打包成一个单一的文件。</p>
<ul>
<li><strong>解决 Windows I/O 瓶颈</strong>：在 Windows 文件系统（NTFS）上，读取成千上万个小文件的开销非常大，且容易触发杀毒软件的实时扫描钩子，导致应用启动缓慢。ASAR 将它们合并为一个大文件，显著提升读取效率。</li>
<li><strong>只读与随机访问</strong>：ASAR 类似于 tar 包，它<strong>不进行压缩</strong>，支持随机访问。这意味着 Electron 可以直接从 ASAR 中读取某个文件的特定字节，而无需解压整个包。</li>
<li><strong>源码保护（有限）</strong>：虽然它稍微隐藏了源代码，避免用户直接在资源管理器中修改文件，但它并非加密技术，简单的 CLI 工具即可解包。</li>
</ul>
<h3 id="52-性能优化的深水区">5.2 性能优化的深水区</h3>
<p>除了 V8 引擎每年带来的原生 JS 性能提升，Electron 在处理高性能场景时还有更多武器：</p>
<ul>
<li>WebAssembly (WASM)：通过 WASM，我们可以将 C/C++ 编写的高性能库（如 FFmpeg、OpenCV）编译后在渲染进程中运行。这让视频剪辑、图像处理等计算密集型任务在 Electron 中达到接近原生的速度（Figma 是最佳案例）。</li>
<li>Worker Threads：为了不阻塞 UI 渲染主线程，繁重的计算任务（如大文件解析、加密解密）应当放入 Worker 线程中执行。</li>
<li>Native Addons (C++)：对于 Node.js 层面都无法满足的性能需求，开发者可以编写 C++ 原生模块（Node Native Addons），直接调用操作系统底层 API，通过 N-API 与 JavaScript 交互。</li>
</ul>
<h3 id="53-强有力的挑战者tauri-与-flutter">5.3 强有力的挑战者：Tauri 与 Flutter</h3>
<p>Electron 的霸主地位正在受到挑战，主要来自追求极致体积和性能的框架：</p>
<ol>
<li>Tauri (Rust + Web 前端)
<ul>
<li>优势：极度轻量。它不打包 Chromium，而是复用操作系统自带的 WebView（Windows 用 WebView2/Edge，macOS 用 WebKit）。安装包通常只有 Electron 的 1/20。</li>
<li>劣势：浏览器兼容性地狱。因为依赖系统 WebView，你无法保证用户电脑上的 WebView 版本是最新的。你可能需要为不同系统的渲染差异写 Polyfill。且后端需掌握 Rust。</li>
</ul>
</li>
<li>Flutter (Dart)
<ul>
<li>优势：自带渲染引擎 (Skia/Impeller)。它不依赖 WebView，直接调用 GPU 绘制 UI，性能极强，体验最接近原生。</li>
<li>劣势：生态隔离。无法直接使用 NPM 上浩如烟海的 JavaScript 库，必须使用 Dart 生态。</li>
</ul>
</li>
<li>Electron 的护城河
<ul>
<li>一致性：因为自带了 Chromium，Electron 保证了<strong>像素级的一致性</strong>。开发者不用担心用户的电脑是 Windows 10 还是 11，网页渲染结果永远一样。这是企业级软件最看重的稳定性。</li>
</ul>
</li>
</ol>
<hr/>
<h2 id="6-总结2026-年我们还应该学-electron-吗">6. 总结：2026 年我们还应该学 Electron 吗？</h2>
<p><strong>答案是肯定的。</strong></p>
<p>虽然它有体积大、吃内存的缺点，但在<strong>构建复杂的、重交互的生产力工具</strong>（如 IDE、设计软件、协同办公软件）方面，Electron 依然是霸主。</p>
<p>它的生态最成熟，坑最少，能在最短时间内把产品做出来并推向所有平台。对于大多数公司和开发者来说，“开发效率”和“跨平台一致性”远比那 100MB 的硬盘空间重要。</p> </div>  <nav class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-12 pt-8 border-t border-border" data-astro-cid-ztig7rse> <a href="/post/2507-claude-code-kimi-k2" class="group flex flex-col gap-1 p-4 rounded-lg border-2 border-text shadow-[4px_4px_0_0_var(--color-text)] hover:translate-x-[2px] hover:translate-y-[2px] hover:shadow-none transition-all" data-astro-cid-ztig7rse> <span class="text-xs text-text-muted flex items-center gap-1 group-hover:text-primary" data-astro-cid-ztig7rse> <div class="i-ri:arrow-left-double-line" data-astro-cid-ztig7rse></div>
上一篇
</span> <span class="font-medium truncate text-text" data-astro-cid-ztig7rse>Claude Code 中接入 Kimi K2 大模型</span> </a> <div data-astro-cid-ztig7rse></div> </nav>  <div class="giscus-container mt-12 pt-8 border-t border-border" data-astro-cid-ztig7rse> <script src="https://giscus.app/client.js" data-repo="AleksChen/AleksChen.github.io" data-repo-id="R_kgDOGjCC6A" data-category="Announcements" data-category-id="DIC_kwDOGjCC6M4CR-S5" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-lang="zh-CN" data-loading="lazy" data-theme="preferred_color_scheme" crossorigin="anonymous" async class="astro-ztig7rse"></script> </div> </article> <aside class="hidden lg:block sticky top-24" data-astro-cid-ztig7rse> <div class="p-4 rounded-lg border-2 border-text bg-card shadow-[4px_4px_0_0_var(--color-text)] max-h-[calc(100vh-8rem)] overflow-y-auto custom-scrollbar" data-astro-cid-ztig7rse> <div class="text-sm font-bold text-text-muted mb-4 uppercase tracking-wider" data-astro-cid-ztig7rse>
目录
</div> <nav class="flex flex-col gap-1 text-sm" data-astro-cid-ztig7rse> <a href="#桌面开发的范式electron-小记" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="桌面开发的范式electron-小记" style="padding-left: 0rem" data-astro-cid-ztig7rse> 桌面开发的范式：Electron 小记 </a><a href="#1-序幕为什么我们需要-electron" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="1-序幕为什么我们需要-electron" style="padding-left: 0.75rem" data-astro-cid-ztig7rse> 1. 序幕：为什么我们需要 Electron？ </a><a href="#11-跨平台开发的痛点" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="11-跨平台开发的痛点" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 1.1 跨平台开发的痛点 </a><a href="#12-electron-的诞生与核心价值" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="12-electron-的诞生与核心价值" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 1.2 Electron 的诞生与核心价值 </a><a href="#2-核心架构揭秘-electron-的运行机制" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="2-核心架构揭秘-electron-的运行机制" style="padding-left: 0.75rem" data-astro-cid-ztig7rse> 2. 核心架构：揭秘 Electron 的运行机制 </a><a href="#21-它们怎么沟通ipc-机制" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="21-它们怎么沟通ipc-机制" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 2.1 它们怎么沟通？(IPC 机制) </a><a href="#22-示例代码" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="22-示例代码" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 2.2 示例代码 </a><a href="#3-设计考量" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="3-设计考量" style="padding-left: 0.75rem" data-astro-cid-ztig7rse> 3. 设计考量 </a><a href="#31-隔离安全与性能" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="31-隔离安全与性能" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 3.1 隔离安全与性能 </a><a href="#32-赋予-web-原生超能力" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="32-赋予-web-原生超能力" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 3.2 赋予 Web 原生超能力 </a><a href="#33-事件循环的融合" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="33-事件循环的融合" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 3.3 事件循环的融合 </a><a href="#4-electron-的局限" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="4-electron-的局限" style="padding-left: 0.75rem" data-astro-cid-ztig7rse> 4. Electron 的局限 </a><a href="#41-内存杀手" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="41-内存杀手" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 4.1 “内存杀手” </a><a href="#42-安全性风险" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="42-安全性风险" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 4.2 安全性风险 </a><a href="#43-体验对比表" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="43-体验对比表" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 4.3 体验对比表 </a><a href="#5-electron-的演进方向" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="5-electron-的演进方向" style="padding-left: 0.75rem" data-astro-cid-ztig7rse> 5. Electron 的演进方向 </a><a href="#51-asar一种特殊的归档格式" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="51-asar一种特殊的归档格式" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 5.1 ASAR：一种特殊的归档格式 </a><a href="#52-性能优化的深水区" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="52-性能优化的深水区" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 5.2 性能优化的深水区 </a><a href="#53-强有力的挑战者tauri-与-flutter" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="53-强有力的挑战者tauri-与-flutter" style="padding-left: 1.5rem" data-astro-cid-ztig7rse> 5.3 强有力的挑战者：Tauri 与 Flutter </a><a href="#6-总结2026-年我们还应该学-electron-吗" class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors truncate" data-id="6-总结2026-年我们还应该学-electron-吗" style="padding-left: 0.75rem" data-astro-cid-ztig7rse> 6. 总结：2026 年我们还应该学 Electron 吗？ </a> </nav> </div> </aside> </div>  </main> <footer class="mt-8 flex flex-col items-center gap-4 py-8"> <div class="flex items-center gap-4"> <a href="https://github.com/AleksChen" target="_blank" class="hover:text-primary transition-transform hover:scale-110 flex items-center gap-1 text-sm font-medium" title="GitHub"> <div class="i-ri:github-fill w-5 h-5"></div> <span class="opacity-80 hover:opacity-100">GitHub</span> </a> <div class="w-px h-4 bg-text opacity-20"></div> <a href="https://juejin.cn/user/254742428393742" target="_blank" class="hover:text-primary transition-transform hover:scale-110 flex items-center gap-1 text-sm font-medium" title="Juejin"> <div class="i-ri:blogger-line w-5 h-5"></div> <span class="opacity-80 hover:opacity-100">Blog</span> </a> <div class="w-px h-4 bg-text opacity-20"></div> <a href="/rss.xml" target="_blank" class="hover:text-primary transition-transform hover:scale-110 flex items-center gap-1 text-sm font-medium" title="RSS"> <div class="i-ri:rss-line w-5 h-5"></div> <span class="opacity-80 hover:opacity-100">RSS</span> </a> </div> <small class="w-full max-w-[720px] min-h-12 flex justify-center items-center opacity-80"> <a href="https://github.com/AleksChen" target="_blank">© 2025 AleksChen</a> </small> </footer> <script type="module">const l=()=>{const e=document.documentElement;e.classList.toggle("dark");const t=e.classList.contains("dark");localStorage.setItem("theme",t?"dark":"light")};document.getElementById("theme-toggle")?.addEventListener("click",l);</script> <script type="module">window.plausible=window.plausible||function(){(plausible.q=plausible.q||[]).push(arguments)},plausible.init=plausible.init||function(i){plausible.o=i||{}};plausible.init();</script> </body> </html> <script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  // 更精确地检测 <html> 是否带有 dark class，优先用 class，否则 fallback 到 media query
  const html = document.documentElement;
  const isDark =
    html.classList.contains("dark") ||
    (!html.classList.contains("light") &&
      window.matchMedia("(prefers-color-scheme: dark)").matches);

  mermaid.initialize({
    startOnLoad: true,
    theme: isDark ? "dark" : "default",
    themeVariables: isDark ? { darkMode: true } : { darkMode: false },
  });
</script> <script type="module">const i=new IntersectionObserver(e=>{e.forEach(o=>{if(o.isIntersecting){const r=o.target.id;document.querySelectorAll(".toc-link").forEach(t=>{t.classList.toggle("text-white",t.getAttribute("data-id")===r),t.classList.toggle("bg-primary/10",t.getAttribute("data-id")===r),t.classList.toggle("font-medium",t.getAttribute("data-id")===r)})}})},{rootMargin:"-100px 0px -60% 0px"});document.querySelectorAll("h1[id], h2[id], h3[id]").forEach(e=>{i.observe(e)});</script> 