{"content":"{\"__ud_title\":\"setTimeout 最小延迟机制\",\"__ud_tags\":[\"JavaScript\"],\"__ud_update_time\":1736410329482,\"__ud_create_time\":1736408029472,\"__ud_draft\":false,\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":1,\"id\":\"setTimeout-最小延迟机制\"},\"content\":[{\"type\":\"text\",\"text\":\"setTimeout 最小延迟机制\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"引言\"},\"content\":[{\"type\":\"text\",\"text\":\"引言\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在 JavaScript 中，\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"setTimeout\"},{\"type\":\"text\",\"text\":\" 是最常用的定时器 API 之一。然而，很多开发者可能并不了解，当我们设置一个理论上的\\\"0毫秒\\\"延迟时，实际上并不会为 0ms。在某些场景下实际执行时间甚至永远不会小于 4ms。这个看似奇怪的限制背后有着深层的技术原因和历史渊源。\"}]},{\"type\":\"paragraph\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"最小延迟值的演变\"},\"content\":[{\"type\":\"text\",\"text\":\"最小延迟值的演变\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"历史变迁\"},\"content\":[{\"type\":\"text\",\"text\":\"历史变迁\"}]},{\"type\":\"bulletList\",\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"1995年：JavaScript 首次在 Netscape Navigator 中引入\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"2003年：IE 实现了 15.625ms 的最小延迟\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"2009年：Firefox 采用了 10ms 的限制\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"2010年：HTML5 规范将嵌套层级大于等于 5 的场景的最小延迟标准化为 4ms，层级小于 5 的情况下最小延迟标准化为 0ms\"}]}]}]},{\"type\":\"paragraph\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"规范依据\"},\"content\":[{\"type\":\"text\",\"text\":\"规范依据\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"HTML-规范\"},\"content\":[{\"type\":\"text\",\"text\":\"HTML 规范\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"根据 HTML Living Standard 规范：\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":1},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"如果设置的 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"timeout\"},{\"type\":\"text\",\"text\":\" 小于 0，则设置为 0\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"如果嵌套的层级超过了 5 层，并且 timeout 小于 4ms，则设置 timeout 为 4ms。\"}]}]}]},{\"type\":\"image\",\"attrs\":{\"src\":\"/post-assets/m5p0iae8-image.png\",\"alt\":\"image.png\",\"title\":null}},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"Chrome-源码分析\"},\"content\":[{\"type\":\"text\",\"text\":\"Chrome 源码分析\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在 Chromium 的源代码中，我们可以看到相关实现：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"cpp\"},\"content\":[{\"type\":\"text\",\"text\":\"static const int kMaxTimerNestingLevel = 5;\\nstatic const double kMinimumInterval = 0.004; // 4ms\"}]},{\"type\":\"paragraph\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"技术原理解析\"},\"content\":[{\"type\":\"text\",\"text\":\"技术原理解析\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"1-事件循环与定时器\"},\"content\":[{\"type\":\"text\",\"text\":\"1. 事件循环与定时器\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"JavaScript 的事件循环机制是理解 setTimeout 行为的关键。定时器不是一个真正的\\\"睡眠\\\"，而是将回调函数放入一个待执行队列。等到满足定时条件后，再执行回调函数。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"2-最小延迟测算\"},\"content\":[{\"type\":\"text\",\"text\":\"2. 最小延迟测算\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"下面是一个测算 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"setTimeout\"},{\"type\":\"text\",\"text\":\" 实际延迟时间的示例\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"javascript\"},\"content\":[{\"type\":\"text\",\"text\":\"// 示例：嵌套定时器的行为\\nfunction nestedTimer(depth = 0) {\\n    const start = performance.now();\\n    setTimeout(() => {\\n        const delay = performance.now() - start;\\n        console.log(`Depth ${depth}, Actual delay: ${delay}ms`);\\n        if (depth < 10) nestedTimer(depth + 1);\\n    }, 0);\\n}\"}]},{\"type\":\"image\",\"attrs\":{\"src\":\"/post-assets/m5p0iae7-image.png\",\"alt\":\"image.png\",\"title\":null}},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"结果分析\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"当嵌套层数少于 5 层时，；理论延迟时间是 0ms；当嵌套层数大于等于 5 层时，理论延迟时间是 4ms（此处和 HTML 规范不一样）。但实际的执行延时受制于事件循环机制，\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"setTimeout\"},{\"type\":\"text\",\"text\":\" 回调需要等待：\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":1},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"当前同步代码执行完；\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"微任务队列情况\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"定时器到期\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"等待下一个宏任务执行时机\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"代码执行开销\"}]}]}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"因此，实际的时延会比设置值向上浮动。但 timeout 值的下限是受到嵌套层级约束的。\"}]},{\"type\":\"paragraph\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"性能影响与优化\"},\"content\":[{\"type\":\"text\",\"text\":\"性能影响与优化\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"1-CPU-和电池影响\"},\"content\":[{\"type\":\"text\",\"text\":\"1. CPU 和电池影响\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"过于频繁的定时器调用会导致：\"}]},{\"type\":\"bulletList\",\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"CPU 使用率上升\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"设备发热增加\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"电池寿命减少\"}]}]}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"2-替代方案\"},\"content\":[{\"type\":\"text\",\"text\":\"2. 替代方案\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"对于需要高精度计时的场景，推荐使用：\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":1},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"requestAnimationFrame\"}]}]}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"javascript\"},\"content\":[{\"type\":\"text\",\"text\":\"requestAnimationFrame(() => { \\n\\t// 用于动画的精确控制 \\n});\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":2},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Web Workers\"}]}]}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"javascript\"},\"content\":[{\"type\":\"text\",\"text\":\"// worker.js \\nsetInterval(() => { \\n\\tpostMessage('tick'); \\n}, 0);\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":3},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Performance.now()\"}]}]}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"javascript\"},\"content\":[{\"type\":\"text\",\"text\":\"const start = Performance.now(); // 用于精确计时\"}]},{\"type\":\"paragraph\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"结论\"},\"content\":[{\"type\":\"text\",\"text\":\"结论\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"setTimeout 的 4ms 最小延迟是一个经过深思熟虑的设计决策，它平衡了开发便利性、性能开销和浏览器兼容性。理解这个机制有助于我们写出更好的异步代码。\"}]},{\"type\":\"paragraph\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"参考资料\"},\"content\":[{\"type\":\"text\",\"text\":\"参考资料\"}]},{\"type\":\"bulletList\",\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout\",\"target\":\"_blank\",\"rel\":\"noreferer\",\"class\":null}}],\"text\":\"HTML Standard\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://mp.weixin.qq.com/s/4P7ohpRmBChXQpLC-MHgHQ\",\"target\":\"_blank\",\"rel\":\"noreferer\",\"class\":null}}],\"text\":\"为什么 setTimeout 有最小时延 4ms ?\"}]}]}]}]}","title":"setTimeout 最小延迟机制","tags":["JavaScript"],"updateTime":1736410329482,"createTime":1736408029472,"draft":false,"intro":"在 JavaScript 中，setTimeout 是最常用的定时器 API 之一。然而，很多开发者可能并不了解，当我们设置一个理论上的\"0毫秒\"延迟时，实际上并不会为 0ms。在某些场景下实际执行时间甚至永远不会小于 4ms。这个看似奇怪的限制背后有着深层的技术原因和历史渊源。","html":"<h1 level=\"1\" id=\"setTimeout-最小延迟机制\">setTimeout 最小延迟机制</h1><h2 level=\"2\" id=\"引言\">引言</h2><p>在 JavaScript 中，<code>setTimeout</code> 是最常用的定时器 API 之一。然而，很多开发者可能并不了解，当我们设置一个理论上的&quot;0毫秒&quot;延迟时，实际上并不会为 0ms。在某些场景下实际执行时间甚至永远不会小于 4ms。这个看似奇怪的限制背后有着深层的技术原因和历史渊源。</p><p></p><h2 level=\"2\" id=\"最小延迟值的演变\">最小延迟值的演变</h2><h3 level=\"3\" id=\"历史变迁\">历史变迁</h3><ul><li><p>1995年：JavaScript 首次在 Netscape Navigator 中引入</p></li><li><p>2003年：IE 实现了 15.625ms 的最小延迟</p></li><li><p>2009年：Firefox 采用了 10ms 的限制</p></li><li><p>2010年：HTML5 规范将嵌套层级大于等于 5 的场景的最小延迟标准化为 4ms，层级小于 5 的情况下最小延迟标准化为 0ms</p></li></ul><p></p><h2 level=\"2\" id=\"规范依据\">规范依据</h2><h3 level=\"3\" id=\"HTML-规范\">HTML 规范</h3><p>根据 HTML Living Standard 规范：</p><ol><li><p>如果设置的 <code>timeout</code> 小于 0，则设置为 0</p></li><li><p>如果嵌套的层级超过了 5 层，并且 timeout 小于 4ms，则设置 timeout 为 4ms。</p></li></ol><img src=\"/post-assets/m5p0iae8-image.png\" alt=\"image.png\"><h3 level=\"3\" id=\"Chrome-源码分析\">Chrome 源码分析</h3><p>在 Chromium 的源代码中，我们可以看到相关实现：</p><div class=\"llt-code readonly\"><div class=\"language\">cpp</div><div class=\"wrapper\"><pre><code class=\"language-cpp\"><span class=\"hljs-type\" class=\"hljs-type\">static</span> <span class=\"hljs-type\" class=\"hljs-type\">const</span> <span class=\"hljs-type\" class=\"hljs-type\">int</span> kMaxTimerNestingLevel = <span class=\"hljs-number\" class=\"hljs-number\">5</span>;\n<span class=\"hljs-type\" class=\"hljs-type\">static</span> <span class=\"hljs-type\" class=\"hljs-type\">const</span> <span class=\"hljs-type\" class=\"hljs-type\">double</span> kMinimumInterval = <span class=\"hljs-number\" class=\"hljs-number\">0.004</span>; <span class=\"hljs-comment\" class=\"hljs-comment\">// 4ms</span></code></pre></div></div><p></p><h2 level=\"2\" id=\"技术原理解析\">技术原理解析</h2><h3 level=\"3\" id=\"1-事件循环与定时器\">1. 事件循环与定时器</h3><p>JavaScript 的事件循环机制是理解 setTimeout 行为的关键。定时器不是一个真正的&quot;睡眠&quot;，而是将回调函数放入一个待执行队列。等到满足定时条件后，再执行回调函数。</p><h3 level=\"3\" id=\"2-最小延迟测算\">2. 最小延迟测算</h3><p>下面是一个测算 <code>setTimeout</code> 实际延迟时间的示例</p><div class=\"llt-code readonly\"><div class=\"language\">javascript</div><div class=\"wrapper\"><pre><code class=\"language-javascript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// 示例：嵌套定时器的行为</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">function</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">nestedTimer</span>(<span class=\"hljs-params\" class=\"hljs-params\">depth = <span class=\"hljs-number\" class=\"hljs-number\">0</span></span>) {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> start = performance.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">now</span>();\n    <span class=\"hljs-built_in\" class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> delay = performance.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">now</span>() - start;\n        <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">console</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">log</span>(<span class=\"hljs-string\" class=\"hljs-string\">`Depth <span class=\"hljs-subst\" class=\"hljs-subst\">${depth}</span>, Actual delay: <span class=\"hljs-subst\" class=\"hljs-subst\">${delay}</span>ms`</span>);\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span> (depth &lt; <span class=\"hljs-number\" class=\"hljs-number\">10</span>) <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">nestedTimer</span>(depth + <span class=\"hljs-number\" class=\"hljs-number\">1</span>);\n    }, <span class=\"hljs-number\" class=\"hljs-number\">0</span>);\n}</code></pre></div></div><img src=\"/post-assets/m5p0iae7-image.png\" alt=\"image.png\"><p><strong>结果分析</strong></p><p>当嵌套层数少于 5 层时，；理论延迟时间是 0ms；当嵌套层数大于等于 5 层时，理论延迟时间是 4ms（此处和 HTML 规范不一样）。但实际的执行延时受制于事件循环机制，<code>setTimeout</code> 回调需要等待：</p><ol><li><p>当前同步代码执行完；</p></li><li><p>微任务队列情况</p></li><li><p>定时器到期</p></li><li><p>等待下一个宏任务执行时机</p></li><li><p>代码执行开销</p></li></ol><p>因此，实际的时延会比设置值向上浮动。但 timeout 值的下限是受到嵌套层级约束的。</p><p></p><h2 level=\"2\" id=\"性能影响与优化\">性能影响与优化</h2><h3 level=\"3\" id=\"1-CPU-和电池影响\">1. CPU 和电池影响</h3><p>过于频繁的定时器调用会导致：</p><ul><li><p>CPU 使用率上升</p></li><li><p>设备发热增加</p></li><li><p>电池寿命减少</p></li></ul><h3 level=\"3\" id=\"2-替代方案\">2. 替代方案</h3><p>对于需要高精度计时的场景，推荐使用：</p><ol><li><p>requestAnimationFrame</p></li></ol><div class=\"llt-code readonly\"><div class=\"language\">javascript</div><div class=\"wrapper\"><pre><code class=\"language-javascript\"><span class=\"hljs-title,function_\" class=\"hljs-title,function_\">requestAnimationFrame</span>(<span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> { \n\t<span class=\"hljs-comment\" class=\"hljs-comment\">// 用于动画的精确控制 </span>\n});</code></pre></div></div><ol start=\"2\"><li><p>Web Workers</p></li></ol><div class=\"llt-code readonly\"><div class=\"language\">javascript</div><div class=\"wrapper\"><pre><code class=\"language-javascript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// worker.js </span>\n<span class=\"hljs-built_in\" class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> { \n\t<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">postMessage</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;tick&apos;</span>); \n}, <span class=\"hljs-number\" class=\"hljs-number\">0</span>);</code></pre></div></div><ol start=\"3\"><li><p>Performance.now()</p></li></ol><div class=\"llt-code readonly\"><div class=\"language\">javascript</div><div class=\"wrapper\"><pre><code class=\"language-javascript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> start = <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Performance</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">now</span>(); <span class=\"hljs-comment\" class=\"hljs-comment\">// 用于精确计时</span></code></pre></div></div><p></p><h2 level=\"2\" id=\"结论\">结论</h2><p>setTimeout 的 4ms 最小延迟是一个经过深思熟虑的设计决策，它平衡了开发便利性、性能开销和浏览器兼容性。理解这个机制有助于我们写出更好的异步代码。</p><p></p><h2 level=\"2\" id=\"参考资料\">参考资料</h2><ul><li><p><a target=\"_blank\" rel=\"noreferer\" href=\"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout\">HTML Standard</a></p></li><li><p><a target=\"_blank\" rel=\"noreferer\" href=\"https://mp.weixin.qq.com/s/4P7ohpRmBChXQpLC-MHgHQ\">为什么 setTimeout 有最小时延 4ms ?</a></p></li></ul><script type=\"module\">const injectHtml = (root, html) => {\n  const iframe = document.createElement(\"iframe\");\n  const htmlContent = `<html><head></head><body>${html}</body></html>`;\n  iframe.style.width = \"100%\";\n  iframe.style.height = \"100%\";\n  iframe.onload = () => {\n    const doc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!doc) {\n      return;\n    }\n    doc.open();\n    doc.write(htmlContent);\n    doc.close();\n  };\n  root.replaceChildren(iframe);\n}\n  document.querySelectorAll('.playground')?.forEach(el=>{\n    const html = el.getAttribute('data-html');\n    if (html) {\n      injectHtml(el,html);\n    }\n    const indicator = document.createElement(\"div\");\n    indicator.className = \"indicator\";\n    const showCode = document.createElement(\"div\");\n    showCode.className = \"show-code\";\n    showCode.innerText = \"code\";\n    showCode.onclick = () => {\n      el.parentElement.classList.remove(\"preview-only\");\n    };\n    const showPreview = document.createElement(\"div\");\n    showPreview.className = \"show-preview\";\n    showPreview.innerText = \"preview\";\n    showPreview.onclick = () => {\n      el.parentElement.classList.add(\"preview-only\");\n    };\n    indicator.appendChild(showCode);\n    indicator.appendChild(showPreview);\n    el.parentElement.appendChild(indicator);\n    if (window.screen.width < 768) {\n      showPreview.click();\n    }\n  });</script>","cover":{"src":"/post-assets/cover/cover-js.png"},"id":"2504-cursor-figma-mcp","path":"/posts/2504-cursor-figma-mcp.json"}