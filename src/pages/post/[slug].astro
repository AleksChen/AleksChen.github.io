---
import Layout from "@/layouts/Layout.astro";
import {
  getPostList,
  getPostBySlug,
  extractIntro,
  getCoverFromTags,
} from "@/lib/posts";
import config from "site.config";
import MDXImage from "@/components/mdx/MDXImage.astro";
import MDXCode from "@/components/mdx/MDXCode.astro";
import MDXTable from "@/components/mdx/MDXTable.astro";

export async function getStaticPaths() {
  const posts = await getPostList(false);
  return posts.map((p, index) => ({
    params: { slug: p.slug },
    props: {
      prev: posts[index + 1] || null,
      next: posts[index - 1] || null,
    },
  }));
}

const { slug } = Astro.params;
const { prev, next } = Astro.props;
const post = await getPostBySlug(slug!);

if (!post) {
  return Astro.redirect("/404");
}

const { Content, headings } = await post.render();

const toc = headings
  .filter((h) => h.depth <= 3)
  .map((h) => ({
    text: h.text,
    id: h.slug,
    depth: h.depth,
  }));

const siteUrl = Astro.site || "https://alekschen.github.io";
const postUrl = `${siteUrl}/post/${post.slug}`;
const showSidebar = post?.showSidebar ?? true;
const coverData = post.data.cover
  ? { src: post.data.cover }
  : getCoverFromTags(post.data.tags);

const coverImage = coverData.src.startsWith("http")
  ? coverData.src
  : new URL(coverData.src, siteUrl).toString();

const intro = post.data.intro || extractIntro(post.body);
---

<Layout
  title={post.data.title}
  description={intro}
  className="max-w-[1200px]"
  seo={{
    type: "article",
    image: coverImage,
    publishedTime: post.data.date.toISOString(),
    modifiedTime: post.data.updatedAt
      ? post.data.updatedAt.toISOString()
      : undefined,
    author: config.head.title,
    tags: post.data.tags,
    url: postUrl,
  }}
>
  <div
    class:list={[
      "grid grid-cols-1 gap-8 items-start",
      { "layout-grid-cols": showSidebar },
    ]}
  >
    <article
      class="w-full min-w-0 bg-card p-4 md:p-8 rounded-lg border-2 border-text shadow-[4px_4px_0_0_var(--color-text)]"
    >
      {/* 文章头部信息 */}
      <header class="mb-8 pb-8 border-b border-border">
        <div class="flex flex-wrap gap-2 mb-4">
          {
            post.data.tags.map((tag) => (
              <a
                href={`/tag/${encodeURIComponent(tag)}`}
                class="px-2 py-1 text-xs font-bold rounded-sm border border-text text-text bg-transparent shadow-[2px_2px_0_0_var(--color-text)] hover:translate-y-[1px] hover:translate-x-[1px] hover:shadow-none transition-all"
              >
                #{tag}
              </a>
            ))
          }
        </div>

        <h1 class="text-3xl md:text-4xl font-bold mb-4 leading-tight text-text">
          {post.data.title}
        </h1>

        <div class="flex items-center gap-4 text-sm text-text-muted">
          <time
            datetime={post.data.date.toISOString()}
            class="flex items-center gap-1"
          >
            <div class="i-ri:calendar-line"></div>
            {post.data.date.toLocaleDateString()}
          </time>
          {
            post.data.updatedAt && (
              <span class="flex items-center gap-1" title="最后更新时间">
                <div class="i-ri:time-line" />
                {post.data.updatedAt.toLocaleDateString()}
              </span>
            )
          }
        </div>
      </header>

      {/* Markdown 内容 */}
      <div
        class="prose prose-lg dark:prose-invert max-w-none break-words prose-a:text-primary prose-a:no-underline hover:prose-a:underline prose-headings:scroll-mt-24"
      >
        <Content
          components={{ img: MDXImage, pre: MDXCode, table: MDXTable }}
        />
      </div>

      {/* 底部导航 (无需 JS Mount) */}
      <nav
        class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-12 pt-8 border-t border-border"
      >
        {
          prev ? (
            <a
              href={`/post/${prev.slug}`}
              class="group flex flex-col gap-1 p-4 rounded-lg border-2 border-text shadow-[4px_4px_0_0_var(--color-text)] hover:translate-x-[2px] hover:translate-y-[2px] hover:shadow-none transition-all"
            >
              <span class="text-xs text-text-muted flex items-center gap-1 group-hover:text-primary">
                <div class="i-ri:arrow-left-double-line" />
                上一篇
              </span>
              <span class="font-medium truncate text-text">{prev.title}</span>
            </a>
          ) : (
            <div />
          )
        }
        {
          next ? (
            <a
              href={`/post/${next.slug}`}
              class="group flex flex-col gap-1 p-4 rounded-lg border-2 border-text shadow-[4px_4px_0_0_var(--color-text)] hover:translate-x-[2px] hover:translate-y-[2px] hover:shadow-none transition-all text-right"
            >
              <span class="text-xs text-text-muted flex items-center gap-1 justify-end group-hover:text-primary">
                下一篇
                <div class="i-ri:arrow-right-double-line" />
              </span>
              <span class="font-medium truncate text-text">{next.title}</span>
            </a>
          ) : (
            <div />
          )
        }
      </nav>

      {/* 评论区 */}
      {
        config.giscus && (
          <div class="giscus-container mt-12 pt-8 border-t border-border">
            <script {...config.giscus} />
          </div>
        )
      }
    </article>

    {
      showSidebar && (
        <aside class="hidden lg:block sticky top-24">
          {toc.length > 0 && (
            <div class="p-4 rounded-lg border-2 border-text bg-card shadow-[4px_4px_0_0_var(--color-text)] max-h-[calc(100vh-8rem)] overflow-y-auto custom-scrollbar">
              <div class="text-sm font-bold text-text-muted mb-4 uppercase tracking-wider">
                目录
              </div>
              <nav class="flex flex-col gap-1 text-sm">
                {toc.map((heading) => {
                  if (!heading.id) return;
                  return (
                    <a
                      href={`#${heading.id}`}
                      class="toc-link block py-1 px-2 text-text-muted hover:text-white rounded transition-colors break-words text-sm leading-snug"
                      data-id={heading.id}
                      style={`padding-left: calc(0.5rem + ${(heading.depth - 1) * 0.75}rem)`}
                    >
                      {heading.text}
                    </a>
                  );
                })}
              </nav>
            </div>
          )}
        </aside>
      )
    }
  </div>
</Layout>

<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  // 更精确地检测 <html> 是否带有 dark class，优先用 class，否则 fallback 到 media query
  const html = document.documentElement;
  const isDark =
    html.classList.contains("dark") ||
    (!html.classList.contains("light") &&
      window.matchMedia("(prefers-color-scheme: dark)").matches);

  mermaid.initialize({
    startOnLoad: true,
    theme: isDark ? "dark" : "default",
    themeVariables: isDark ? { darkMode: true } : { darkMode: false },
  });
</script>

<script>
  // TOC 滚动高亮逻辑
  let isManualScroll = false;
  let scrollTimeout: NodeJS.Timeout;

  // 提取更新高亮样式的函数
  const updateActiveLink = (id: string) => {
    document.querySelectorAll(".toc-link").forEach((link) => {
      const isActive = link.getAttribute("data-id") === id;
      link.classList.toggle("text-white", isActive);
      link.classList.toggle("bg-primary/10", isActive);
      link.classList.toggle("font-medium", isActive);
    });
  };

  const observer = new IntersectionObserver(
    (entries) => {
      // 如果是手动点击触发的滚动，不进行 Observer 更新
      if (isManualScroll) return;

      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const id = entry.target.id;
          updateActiveLink(id);
        }
      });
    },
    {
      rootMargin: "-100px 0px -60% 0px", // 调整视口检测范围
    }
  );

  document.querySelectorAll("h1[id], h2[id], h3[id]").forEach((h) => {
    observer.observe(h);
  });

  // 处理点击事件
  document.querySelectorAll(".toc-link").forEach((link) => {
    link.addEventListener("click", (e) => {
      isManualScroll = true;
      const id = (e.currentTarget as HTMLElement).getAttribute("data-id");
      if (id) updateActiveLink(id);

      // 清除旧定时器
      if (scrollTimeout) clearTimeout(scrollTimeout);
      
      // 假设滚动动画最长持续 800ms，之后恢复 Observer
      scrollTimeout = setTimeout(() => {
        isManualScroll = false;
      }, 800);
    });
  });
</script>

<style>
  @media (min-width: 1024px) {
    .layout-grid-cols {
      grid-template-columns: minmax(0, 1fr) 240px;
    }
  }
</style>
